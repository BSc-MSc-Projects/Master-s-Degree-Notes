\documentclass[18px]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{cases}
\usepackage{graphicx}

\begin{document}
\tableofcontents
\section{Schedulabilità di algoritmi a priorità fissa}
Algoritmi a priorità dinamica, come EDF, sono ottimali (sotto determinate condizioni): se $\exists$ schedulazione fattibile $\Rightarrow$ anche EDF trova schedulazione.\\ Nessun algoritmo X a priorità fissa può avere un fatto di utilizzazione U$_{X}$ = 1, deve per forza essere $<$ 1.\\ Inoltre RM è ottimale (in senso assoluto, ovvero può raggiungere U = 1) per sistemi armonici con scadenze implicite.\\ In questa condizione RM è tanto buono quanto EDF.\\ DM è ottimale tra gli algoritmi a priorità fissa, ma non in senso assoluto: se $\exists$ algoritmo a priorità fissa che trova una schedulazione fattibile per un insieme di task, allora lo fa anche DM. Questo mi fa capire assegnare priorità fisse ai task,in modo arbitrario, non fa guadagnare nulla rispetto ad assegnarle con un parametro come la scadenza relativa. Algoritmo è altrettanto buono, se non più buono di algoritmi che fissano le scadenze in modo soggettivo, posso realizzare sistemi di task basati su parametri oggettivi e non soggettivi.\\ Corollario: RM è ottimale tra gli algoritmi a priorità fissa per sistemi ti task con scadenza proporzionale al periodo.\\ Mi pongo un problema generale: se ho sys di task generale ed un algoritmo di schedulazione a priorità fissa, come faccio a verificare il sistema, ovvero a certificare che l'algoritmo produrrà sempre una schedulazione valida?
\subsection{Istanti critici}
Istanti critici: suppongo che nel sys di task tutti i job abbiano un tempo di risposta piccolo, ovvero ogni job termina prima del rilascio del job successivo del task $\Rightarrow$ ogni job viene rilasciato in un periodo e si conclude entro quel periodo (job potrebbe non rispettare la scadenza, se questa è minore del periodo).\\ L'istante critico è il momento in cui il rilascio del job comporta il massimo tempo di risposta possibile  per quel job.\\ Se almeno un job T$_{i}$ non rispetta la scadenza relativa, l'istante critico è un momento in cui il rilascio di un job provoca il mancato rispetto della scadenza di quel job.\\ Io voglio verificare che tutti i job rispettino le scadenze, sottigliezza della definizione è irrilevante dal punto di vista critico.\\ Teorema: Se ho un sistema di task a priorità fissa e tempi di risposta piccoli, l'istante in cui uno dei job di T$_{i}$  viene rilasciato contemporaneamente ai job di tutti i task con priorità maggiore di T$_{i}$ è l'istante critico di T$_{i}$.\\ Teorema non da condizione necessaria e sufficiente, ma solo sufficiente: se capita tale condizione $\Rightarrow$ ho un istante critico, ma potrei averne altri.\\ esempio : T$_{1}$=(2, 0.6) T$_{2}$=(2.5,0.2), T$_{3}$=(3,1.2).\\ T$_{1}$ ha la priorità massima: tutti i multipli di 2 sono istanti critici.\\ T$_{2}$ ha istanti critici 0 e 10, che sono anche i momenti in cui rilascio job di T$_{1}$, non c'è nessun altro momento in cui c'è rilascio contemporaneo di job di T$_{1}$ e T$_{2}$.\\ T$_{3}$ avrà rilasci in 0, 3, 6, 9: in 0 ho istante critico, 6 e 9 sono critici ma il thm non li evidenzia.\\
\includegraphics[scale=0.2]{images/SERT1710.png}\\
Stesso esempio anche se i task non sono in fase: 6 è istante critico, è descritto dal teorema.\\ Quando c'è rilascio in fase, siccome priorità è fissa, la schedulazione prodotta risulta identica a qualsiasi schedulazione non in fase $\Rightarrow$ mi interessa ricondurmi a quando tutti i task sono in fase.
\subsection{Schedulabilità per priorità fissa e tempi di risposta piccoli}
Supponiamo che in un sistema ho task a priorità fissa e tempi di risposta piccoli.\\ Ordino i task per priorità decrescente, suppongo siano in fase all'istante t$_{0}$.\\ Ho i task T$_{1}$......T$_{i}$ e mi chiedo il tempo necessario per eseguire tutti i job dei task T$_{1}$......T$_{i}$, nell'intervallo [t$_{0}$, t$_{0}$+t] (t $\leq$ p$_{i}$:\\
w$_{i}$(t) = e$_{i}$ +  $\sum\limits_{k=0}^{i-1} \lceil\frac{t}{p_{k}}\rceil \cdot e_{k}$.\\ Somma si estende su tutti i task di priorità superiore di T$_{i}$, devo considerarli perché portano via tempo al job di T$_{i}$. Prendo k-esimo task: a t$_{0}$ tutti i task sono in fase, quindi rilascio sicuro un job, quando ne rilascio? Prendo il ceil di $\frac{t}{p_{k}}$,anche job rilasciato nel periodo dopo quello considerato mi ruba tempo; moltiplico tutto per e$_{k}$, il tempo che ci metto per completare i job.\\ Test di schedulabilità: dati job T$_{1}$......T$_{i}$, in fase a t$_{0}$ con priorità decrescenti con T$_{1}$......T$_{i-1}$ effettivamente schedulabili. Il task T$_{i}$ può essere schedulato nell'intervallo di tempo [t$_{0}$, t$_{0}$+D] se $\exists$ t $\leq$ D$_{i}$ tale che w$_{i}$(t) $\leq$ t. IL mio scopo è sempre quello di verificare la schedulabilità del sistema, se ne trovo uno non schedulabile la mia analisi è finita, non ci faccio nulla col sistema di task.\\ Applicazione: ho T$_{1}$......T$_{n}$ con priorità decrescenti. \\Considero un task alla volta: $\forall$ task T$_{i}$  calcolo il valore della funzione di tempo necessario w$_{i}$(t) per tutti i valori t $\leq$D$_{i}$ tali per cui t è un multiplo intero di p$_{k}$ per k $\in$ \{1,2....,i \}.Funzione w$_{i}$(t) sale a gradini, devo considerare valori per cui tale funzione cambia valori.\\ Se per almeno uno dei valori t vale che w$_{i}$(t) $\leq$ t allora T$_{i}$ è effettivamente schedulabile. Altrimenti il test fallisce, ovvero n job di T$_{i}$ potrebbe mancare la scadenza, ovvero la manca sicuro se c'è un rilascio di tutti i job in fase dei task di priorità superiore e tutti quei task hanno un tempo di esecuzione pari al loro worst-case.\\ Possono esserci casi fortuiti, quindi in ipotesi rilassate il test non conferma schedulabilità ma scheduler riesce, però il risultato non è rilevante.\\Tanto vale fermarsi e riprogettare il sistema.\\
esempio: T$_{1}$=(3,1), T$_{2}$=(5,1.5), T$_{3}$=(7, 1.25), T$_{4}$=(9,0,5) e considero le funzioni di tempo necessario:\\
\includegraphics[scale=0.3]{images/SERT1710_1.png}\\
Grafico per l'esempio precedente, ho la bisettrice del 1° quadrante, dire che w$_{i}$(t) è $\leq$ t vuol dire che w$_{i}$(t) sta sotto la bisettrice. La funzione è a scalini, non ha senso calcolarla, la applico nel periodo tra 0 e la fine del periodo.In T$_{2}$ la funzione sale sopra la bisettrice, ma non è importante: devo verificare che sia sotto in un certo momento, se fosse sempre sopra non sarebbe schedulabile.\\ Ogni volta che c'è rilascio di un task a priorità superiore $\Rightarrow$ ho gradino nella funzione di tempo necessario.\\
\includegraphics[scale=0.2]{images/SERT1710_2.png}\\
\subsection{Massimo tempo di risposta}
Massimo tempo di risposta W$_{i}$ di T$_{i}$ è il più piccolo valore prima della scadenza relativa t.c : t=w$_{i}$(t). Se l'equazione non ha soluzioni $\leq$ a D$_{i}$, allora qualche job di T$_{i}$ mancherà la scadenza relativa.\\ Uso un algoritmo:\\
\begin{itemize}
\item $t^(1)$ = e$_{1}$ in prima approssimazione
\item  Sostituisco nella funzione ed ottengo un nuovo valore $t^(k+1)$ = w$_{i}$($t^(k)$)
\item continuo ad iterare finché: 
\begin{itemize}
\item $t^(k+1)$ = $t^(k)$ e $t^(k)$ $\leq$ D$_{i}$ $\Rightarrow$ W$_{i}$ = $t^(k)$
\item $t^(k)$ $\geq$ D$_{i}$ e allora sono fuori scadenza
\end{itemize}
\end{itemize}
Ma dato che caso peggiore sono task in fase e dato che ho tutti i parametri sono noti, non sarebbe più facile provare a simulare la schedulazione? Sì, ma ci sono dei fattori che non ho considerato e che mi impediscono di simulare, esempio:
\begin{itemize}
\item Non è possibile determinare facilmente il worst case
\item Il worst case cambia da task a task
\item È difficile integrare nella simulazione altri fattori che possono essere considerati estendendo il test di schedulabilità.
\end{itemize}
In ogni caso, sia simulare il test che il test di schedulabilità stesso hanno la stessa complessità.
\subsubsection{Task periodici con tempi di risposta arbitrari}
Considero ora task con tempi di risposta arbitrari, che implica che: 
\begin{itemize}
\item Un job non deve necessariamente prima che il job successivo dello stesso task sia eseguito
\item è possibile che D$_{i}$ $\geq$ di p$_{i}$
\item Ci possono essere nello stesso istante più job di uno stesso task in attesa di essere eseguiti.
\item Un job rilasciato contemporaneamente a tutti i job dei task con priorità maggiore non ha necessariamente il massimo t. di risposta possibile.
\end{itemize}
Assumo sempre che i job di uno stesso task hanno vincoli di precedenza impliciti fra di loro, ovvero sempre eseguiti FIFO.\\ Analizzo task per task: considero T$_{i}$ (i precedenti sono schedulabili). Ho insieme task $\tau_{i}$=T$_{1}$....T$_{i}$ con priorità decrescente. \\Definisco un intervallo totalmente occupato di un livello $\pi_{i}$ un intervallo (t$_{0}$, t$_{1}$] tale che:
\begin{itemize}
\item all'istante t$_{0}$ tutti i job di $\tau_{i}$ rilasciatiti prima di t$_{0}$ sono stati completati
\item All'istante t$_{0}$ un job di $\tau_{i}$ viene rilasciato.
\item L'istante t$_{1}$ è il primo istante in cui tutti i job di $\tau_{i}$ rilasciati a partire da t$_{0}$ sono stati completati
\end{itemize}
È possibile che in un intervallo totalmente occupato il processore sia idle o esegua task non di $\tau_{i}$? No: se fosse idle, l'intervallo terminerebbe prima, non può neanche eseguire task di priorità inferiore, quindi non può eseguire task al di fuori di $\tau_{i}$\\
esempio: T$_{1}$, T$_{2}$, T$_{3}$.\\ Intervalli di T$_{3}$ non sono lunghi uguale, questo perché i rilasci di T$_{3}$ non sono in concomitanza con T$_{1}$ e T$_{2}$, posso dire che l'intervallo a lunghezza massimo quando i rilasci di tutti i task sono in fase.\\ Test di schedulabilità generale per tempi di risposta arbitrari è ancora basato sul caso peggiore, la differenza rispetto al test per tempi piccoli è che il primo job rilasciato contemporaneamente agli altri potrebbe non avereil massimo tempo di risposta.\\ Idea : $\forall$ T$_{i}$ analizzo tutti i suoi job eseguiti nel primo intervallo totalmente occupato di livello $\pi_{i}$. \\ Come determino l'intervallo totalmente occupato: 
\begin{itemize}
\item Inizio determinato dal rilascio dei primi job (in fase) dei task $\tau_{i}$=\{T$_{1}$, ...., T$_{i}$\}
\item Lunghezza massima calcolata risolvendo iterativamente t = $\sum\limits_{k=1}^{i}\lceil\frac{t}{p_{k}}\rceil \cdot e_{k}$. Molto simile alla funzione di tempo necessario, dico che aumento t fino a che non trovo il valore dato dalla sommatoria, ovvero il primo t per cui il lavoro necessario per compiere tutti i task permette di eseguire tutti i task rilasciati nell'intervallo [t$_{0}$, t$_{0}$+t] 
\end{itemize}
Quindi si procede nel seguente modo:
\begin{itemize}
\item Considero i task \{T$_{1}$, ...., T$_{i}$\} con priorità $\pi_{1}$ $<$ $\pi_{2}$....$<$ $\pi_{i}$, considero un task T$_{i}$ alla volta cominciando da quello con la massima priorità, ovvero T$_{1}$
\item Il caso peggiore per la schedulabilità di T$_{i}$: assumere che i task $\tau$ $_{i}$ = \{T$_{1}$, ...., T$_{i}$\} sono in fase.
\item Se il primo job di tutti i task in $Tau_{i}$ termina entro il primo periodo del task $\Rightarrow$ decidere se T$_{i}$ è  schedulabile si effettua controllando se J$_{i,1}$ termina entro la scadenza tramite la funzione di tempo richiesto w$_{i,1}$ := w$_{i}$(t)
\item Altrimenti almeno un primo job di $Tau_{i}$ termina dopo il periodo del task, calcola la lunghezza $t^L$ dell'intervallo totalmente occupato di livello $\pi_{i}$ che inizia da t = 0.
\item Calcolo i tempi di risposta massimi di tutti i job di T$_{i}$ dentro l'intervallo totalmente occupato che sono $\lceil$ $\frac{t^L}{p_{i}}$ $\rceil$; il primo l'ho già calcolato.
\item Decido se questi job sono schedulabili dentro l'intervallo totalmente occupato. Uso un lemma:\\
Il tempo di risposta massimo W$_{i,j}$ del j-esimo job di T$_{i}$, in un intervallo totalmente occupato di livello $\pi_{i}$ in fase è uguale al minimo t che soddisfa l'equazione t = w$_{i,j}$(t+(j-1)$\cdot$ p$_{i}$) - (j-1)$\cdot$ p$_{i}$, con w$_{i,j}$(t) = j$\cdot$e$_{i}$ + $\sum\limits_{k=1}^{i-1}\lceil\frac{t}{p_{k}}\rceil \cdot e_{k}$.\\ Aggiungo un j che moltiplica e$_{i}$, devo verificare l'equazione nei punti multipli.\\ 
\end{itemize}
esercizio:
T$_{1}$ = ($\phi_{1}$,2,1,1), T$_{2}$ = ($\phi_{2}$,3,1.25,4), T$_{3}$ = ($\phi_{3}$,5,0.25,7)\\ Parto verificando T$_{1}$: \\w$_{1}$(t) = w$_{1,1}$(t) = e$_{1}$ = 1 = D$_{1}$. Quindi è sicuramente schedulabile . \\T$_{2}$:\\
w$_{2,1}$(2) = e$_{1}$ + e$_{2}$ = 2.25 $>$ 2, quindi non va bene. Vado avanti: \\
w$_{2,1}$(3) = 2$\cdot$e$_{1}$ + e$_{2}$ = 3.25 $>$ 3. Non va ancora bene, proseguo: \\
w$_{2,1}$(4) = 2$\cdot$e$_{1}$ + e$_{2}$ = 3.25 $\leq$ 4 $\leq$ $D_{2}$ quindi T$_{2}$ è schedulabile, ma ha completato oltre il periodo $\Rightarrow$ non posso più considerare tempi piccoli, devo considerare gli intervalli totalmente occupati, uso l'equazione iterativa:\\
$t^(1)$ = e$_{1}$ + e$_{2}$ = 2.25, sostituisco nella sommatoria,ed ottengo $t^(2)$ = 2$\cdot$e$_{1}$ + e$_{2}$ = 3.25, $t^(3)$ = 2$\cdot$e$_{1}$ + 2$\cdot$e$_{2}$ = 4.5, $t^(4)$ = 3$\cdot$e$_{1}$ + 2$\cdot$e$_{2}$ = 5.5, $t^(5)$ = 3$\cdot$e$_{1}$ + 3$\cdot$e$_{2}$ = 5.5 $\Rightarrow$ $t^(4)$ = $t^L$, ovvero intervallo totalmente occupato di livello 2 è 5.5.\\ Ora calcolo quanti job di T$_{2}$ ci sono in (0, 5.5] = $\lceil$ $\frac{t^L}{p_{2}}$ $\rceil$ = 2.\\ Veridico il secondo job di T$_{2}$:\\
w$_{2,2}$(3) = 2$\cdot$e$_{1}$ + 2$\cdot$e$_{2}$ = 4.5 $>$ 3, no\\
w$_{2,2}$(4) = 2$\cdot$e$_{1}$ + 2$\cdot$e$_{2}$ = 4.5 $>$ 4, ancora no.\\
w$_{2,2}$(3) = 3$\cdot$e$_{1}$ + 2$\cdot$e$_{2}$ = 5.5 $\leq$6 $\leq$ $p_{2}$+$D_{2}$=7, quindi accetto il task.\\ Ora devo capire  se posso accettare T$_{3}$, e considerare l'intervallo totalmente occupato di lvl 3:\\ 
$t^(1)$ = e$_{1}$ + e$_{2}$ +e$_{3}$ = 2.5\\
$t^(2)$ = 2$\cdot$e$_{1}$ + e$_{2}$ +e$_{3}$ = 3.5\\
$t^(3)$ = 2$\cdot$e$_{1}$ + 2$\cdot$e$_{2}$ +e$_{3}$ = 4.75\\
$t^(4)$ = 3$\cdot$e$_{1}$ + 2$\cdot$e$_{2}$ +e$_{3}$ = 5.75\\
$t^(5)$ = 3$\cdot$e$_{1}$ + 2$\cdot$e$_{2}$ + 2$\cdot$e$_{3}$ = 6\\
$t^(6)$ = 3$\cdot$e$_{1}$ + 2$\cdot$e$_{2}$ + 2$\cdot$e$_{3}$ = 6 = $t^L$\\
\# job di T$_{3}$ nell'intervallo (0,6]: $\lceil$ $\frac{t^L}{p_{3}}$ $\rceil$ = 2. Considero i  singoli job:\\
w$_{3,1}$(2) = e$_{1}$ + e$_{2}$ + e$_{3}$ = 2.5 $>$ 2, no.\\
w$_{3,1}$(3) = 2$\cdot$e$_{1}$ + e$_{2}$ + e$_{3}$ = 3.5 $>$ 3, no.\\
w$_{3,1}$(4) = 2$\cdot$e$_{1}$ + 2$\cdot$e$_{2}$ + e$_{3}$ = 4.75 $>$ 4, no.\\
w$_{3,1}$(5) = 3$\cdot$e$_{1}$ + 2$\cdot$e$_{2}$ + e$_{3}$ = 5.75 $>$ 5, no.\\
w$_{3,1}$(6) = 3$\cdot$e$_{1}$ + 2$\cdot$e$_{2}$ + e$_{3}$ = 5.75 $\leq$ 6 $\leq$ D$_{3}$ = 7. Posso accettare il job\\\\
w$_{3,2}$(5) = 3$\cdot$e$_{1}$ + 2$\cdot$e$_{2}$ + 2$\cdot$e$_{3}$ = 6 $>$ 5, no.\\
w$_{3,2}$(6) = 3$\cdot$e$_{1}$ + 2$\cdot$e$_{2}$ + 2$\cdot$e$_{3}$ = 6 $\leq$ 6 $\leq$ p$_{3}$ + D$_{3}$ = 12 Accetto il job, e quindi il task.\\ Tutti i task sono schedulabili a prescindere dai loro task.\\ 
\subsection{Condizioni di schedulabilità}
Il test di schedulabilità generale determina se insieme di task è schedulabile o no, considerando worst case che è task in fase.\\ Ho dei limiti:
\begin{itemize}
\item Devo conoscere tutti i periodi, le scadenze ed i tempi d'esecuzione. Per validazione è necessario, ma no per implementazione di scheduler a priorità fissa. Se voglio aggiungere un task dovrei conoscere parametri che in fase di progettazione del sw non servono.
\item Il risultato ottenuto non è valido se il task varia periodo, scadenza o tempo di esecuzione.
\item È computazionalmente costoso, poco adatto per scheduling on-line.
\end{itemize}
Cerco di trovare delle condizioni di schedulabilità, confronto il test con la condizione, che è molto più semplice da calcolare e che può essere applicata anche se alcuni parametri non sono noti (esempio: condizione di EDF).\\ Mi chiedo se $\exists$ condizione di schedulabilità per algoritmi a priorità fissa:\\ Condizione di Liu-Layland: sistema $\tau$ di n task indipendenti ed interrompibili con scadenze relative uguali ai rispettivi periodi può essere effettivamente schedulato su un processore in accordo con RM se il suo fattore di utilizzazione U$_{\tau}$ è $\leq$ a U$_{RM}$(n) = n$\cdot$($2^{\frac{1}{n}}$-1)\\ Questo è il fattore di utilizzazione di RM, se considero: $\lim_{n \to \inf}$ U$_{RM}$(n) = ln2, ovvero RM in generale garantisce di rispettare le scadenze pur di non caricare il processore per più del 69.3.\\ Ho un criterio per adottare RM negli scheduler real-time.\\ esempio:\\ T$_{1}$ = (1,0.25), T$_{2}$ = (1.25,0.1), T$_{3}$ = (1.5,0.3), T$_{4}$ = (1.75,0.07), T$_{5}$ = (2,0.1). U$_{\tau}$ = 0.62 $\leq$ 0.743 = U$_{RM}$(5) $\Rightarrow$ è schedulabile con RM.\\ IL sistema T$_{1}$ = (3,1), T$_{2}$ = (5,1.5), T$_{3}$ = (7,1.25), T$_{4}$ = (9,0.5) ha fattore di utilizzazione U$_{\tau}$ = 0.867 $>$ 0.757 = U$_{RM}$(4),  forse non schedulabile.\\ È condizione sufficiente, difatti l'esempio 2 era quello precedente che è schedulabile se applico la funzione di tempo necessario.\\ L'alternativa a questo risultato è il test iperbolico: Un sistema $\tau$ di n task indipendenti ed interrompibili con scadenze relative uguali ai rispettivi periodi può essere effettivamente schedulato su un processore RM se $\prod\limits_{k=1}^{n}(1 + \frac{e_{k}}{p_{k}})$ $\leq$ 2.\\ SI applica anche questo conoscendo solo fattore di utilizzazione dei task. \\ Correlazione con condizione di Liu-Layland: se gli n task hanno tutti lo stesso rapporto $\frac{e_{k}}{p_{k}}$ vuol dire che ciascun di questi usa una porzione uguale del processore. \\ Si può dimostrare che se questo è vero allora, assumendo u$_{k}$ = $\frac{U_{\tau}}{n}$:\\
$\prod\limits_{k=1}^{n}(1 + \frac{e_{k}}{p_{k}})$ $\leq$ 2 $\Leftrightarrow$ U$_{\tau}$ $leq$ n$\cdot$($2^{\frac{1}{n}}$-1). \\Se questo non è vero, esistono casi in cui il test iperbolico è soddisfatto, ma la condizione di Liu-Layland no; non esiste invece mai il viceversa.\\
\subsection{Test per sottoinsiemi di task armonici}
So che ,in generale RM è schedulabile se è soddisfatta condizione di Liu-Layland, ma so anche che su task armonici è ottimale. Suddivido insiemi di task in sottoinsiemi di task armonici fra loro.\\ Condizione di Kuo-Mok: se sistema $\tau$ di task periodici, indipendenti ed interrompibili con p$_{i}$ = D$_{i}$ può essere partizionato in n$_{h}$ sottoinsiemi disgiunti Z$_{1}$,....,Z${n_{h}}$, ciascuno dei quali contiene task semplicemente periodici, allora il sistema è schedulabile con RM se:\\
$\sum\limits_{k=1}^{n_{h}}U_{Z_{k}}(n_{h})$ oppure se $\prod\limits_{k=1}^{n_{h}}(1+U_{Z_{k}})$ $\leq$ 2.\\ Se un sistema ha poche applicazioni molto complesse, è possibile migliorare la schedulabilità rendendo i task di ciascuna applicazione semplicemente periodici.\\ Esempio: 9 task con periodi 4,7 ,7 , 14, 16, 28, 32, 56, 64, fattore di utilizzazione di Liu-Layland è U$_{RM}$ = 0.720\\ Considero i multipli di 2 e 7 e partizionando in due sottoinsiemi ottengo U$_{Z_{1}}$ + U$_{Z_{2}}$ $\leq$ U$_{RM}$(2) = 0.828.\\\\ Il fattore di RM è in generale U$_{RM}$(n), ma posso farlo diventare pari ad 1 per task semplicemente periodici.\\ Miglioro U$_{RM}$(n) considerando quanto i periodi dei task sono vicini ad essere armonici:\\
X$_{i}$ = log$_{2}$p$_{i}$ - $\lfloor$ log$_{2}$p$_{i}$ $\rfloor$ e $\zeta$ = max$_{1 \leq i \leq n}$X$_{i}$ - min$_{1 \leq i \leq n}$X$_{i}$\\ Considero il valore frazionario del log$_{2}$ e prendo tutti i task, di cui faccio differenza tra max e min di questi scarti decimali.\\ Teorema: nelle ipotesi della condizione di Liu-Layland, il fattore di utilizzazione di RM dipende dal numero di task n e da $\zeta$ è: 
U$_{RM}$(n, $\zeta$) =
\begin{itemize}
\item (n-1)$\cdot$($2^\frac{\zeta}{(n-1)}$-1) + $2^{(1-\zeta)}$-1  se $\zeta$ $<$ 1 - $\frac{1}{n}$
\item U$_{RM}$(n)
\end{itemize}
Quando si verifica il caso $\zeta$ = 0? Quando p$_{i}$ = K$\cdot$ $2^{x_{i}}$; non è vero il contrario\\
Variante: schedulabilità per scadenze arbitrarie. Se per qualche task la scadenza è più grande del periodo il limite è valido? Sì, però la formula è "pessimista": forse è possibile trovare valori di soglia superiori a U$_{RM}$.\\ Se invece per qualche task il periodo è più grande della scadenza non posso applicare Liu-Layland.\\ Teorema:	\\
Un sistema $\tau$ di n task indipendenti, interrompibili e con scadenze D$_{i}$ = $\delta$p$_{i}$ è schedulabile con RM se U$_{\tau}$ è $\leq$ a:
U$_{RM}$(n, $\delta$) =
\begin{itemize}
%\begin{cases}
\item $\delta$(n-1)$\cdot$($\frac{\delta+1}{\delta}^{\frac{1}{(n-1)}}$ - 1)  per $\delta$ = 2,3,.....
\item n($2\delta^{\frac{1}{n}}$-1) + 1 - $\delta$ per 0.5 $\leq$ $\delta$ $\leq$ 1
\item $\delta$ per 0 $\leq$ $\delta$ $\leq$ 0.5
%\end{cases}
\end{itemize}
\section{Schedulazione di job bloccanti e job aperiodici}
Avevo un modello semplice, devo rilassare qualcuna delle ipotesi dovute al fatto che i job siano sempre sempre interrompibili, o che costo di context switching sia 0. Nella pratica molti fattori rallentano l'esecuzione di un job, che possono portare a mancata scadenza. Devo tenerne conto, divido in due genti classi:
\begin{itemize}
\item Tempi di blocco: job non può essere eseguito nonostante il rilascio, per via di fattori esterni. Ad esempio: sul processore c'è un job non interrompibile, job rilasciato è quindi bloccato per un certo tempo. Modellati definendo b$_{i}$ = tempo massimo di blocco, che tiene conto di tutti i tempi che fanno si che il job non può eseguire, va sottratto al tempo a disposizione del job.
\item rallentamenti sistematici: ho calcolato il worst case di un job, ma a questo devo considerare il tempo che ci mette il job ad essere posto in esecuzione e ad essere tolto una volta completato, o anche il tempo che ci mette lo scheduler a decidere. Se questo tempo ha impatto pratico può avere senso modellarlo. Sommo al worst case del job.
\end{itemize}
\subsection{Auto-sospensione}
Un job rilasciato non può essere eseguito perché in attesa di eventi esterni, la cosa migliore da fare in questi casi è mettere in esecuzione un altro job. Si dice che il job si è auto-sospeso:
\begin{itemize}
\item job è un processo ed esegue operazione di accesso alla memoria di massa, ha senso sostituire il processo mentre questo attende i dati.
\item attendo dati da rete/altri job
\item attendo scadenza di un timer
\end{itemize}
Nei SO questo tipo di operazioni sono chiamate operazioni bloccanti, nell'ambito real-time ci possono essere operazioni di auto-sospensione che però non è bloccante: in questo ambito ha senso attivo, ovvero un job ne blocca un altro. Anche in questo caso ci sono conseguenze su un altro job.\\ Supponiamo che ogni job di un task T$_{i}$ si auto-sospende per un certo tempo x, in questo caso non appena rilasciato. Come schedulo: considero l'istante di rilascio come p$_{i}$-x, e la scadenza relativa come D$_{i}$-x.\\ Approccio semplificato, non funziona nel caso in cui i job si auto-sospendono solo all'inizio o per un tempo determinato, devo definire il tempo massimo di auto-sospensione b$_{i}$(ss).\\ esempio: T$_{1}$ = (4, 2.5) T$_{2}$ = (3.7, 2, 7) schedulato con RM. Se primo job di T$_{1}$ si auto-sospende subito dopo il rilascio, le cose possono andare male: il primo job del task T$_{2}$ manca la scadenza, job di T$_{1}$ si risveglia in modo che per completare occupa tutto il suo periodo, quindi quando job di T$_{2}$ comincia esecuzione di porta avanti ma non riesce a finire.\\
\includegraphics[scale=0.3]{images/SERT2210.png}\\
Ho impatto sui job di priorità inferiore: anche se job si auto-sospende on no lo fa, se c'è job di priorità superiore non è danneggiato, ma quelli di priorità inferiore si.
\subsubsection{Rallentamento dovuto all'auto-sospensione}
1° caso: il tempo di auto-sospensione di un job è maggiore della durata del job: job di T$_{i}$ con priorità inferiore è rallentato al massimo per un tempo pari alla durata del job di T$_{k}$ È il worst case: job T$_{i}$ non riesce ad arrivare mente job di T$_{k}$ è in auto-sospensione\\
\includegraphics[scale=0.3]{images/SERT2210_1.png}\\
2° caso: il tempo di auto-sospensione di un job è minore della durata del job. Un job di T$_{i}$ con priorità minore è rallentato al massimo per un tempo pari alla durata dell'auto sospensione.\\
\includegraphics[scale=0.3]{images/SERT2210_2.png}
\subsubsection{Tempo massimo di sospensione di blocco per auto-sospensione}
Dato task T$_{k}$ chiamo x$_{k}$ il tempo massimo di sospensione di ciascun job di T$_{k}$, questo è un parametro del sistema.\\ Prendo task T$_{i}$ con priorità minore, il rallentamento inflitto ad un job T$_{i}$ da un job di T$_{k}$ è minore o uguale ad x$_{k}$ e minore o uguale ad e$_{k}$:
b$_{i}$(ss) = x$_{i}$ + $\sum\limits_{k = 1}^{i-1}min(e_{k}, x_{k})$.\\ Manca qualcosa, sto assumendo che un job si auto-sospenda una volta sola, ma non c'è nessun motivo reale per cui questo sia vero: job può auto-sospendersi più volte, devo contare il numero di volte. Devo definire anche il massimo numero di volte k$_{i}$ in cui un job di T$_{i}$ si sospende.\\ Difatti:
\begin{itemize}
\item si può verificare un blocco da parte di un processo non interrompibile
\item si ha un rallentamento dovuto allo scheduler ed al costo del context switching
\end{itemize}
\subsection{Non interrompibilità dei job}
Assunzione irrealistica che i job non siano interrompibili, esistono sempre istanti in cui il job non è interrompibile:
\begin{itemize}
\item se sta operando su area di memoria critica
\item se sta interagendo con dispositivo hardware
\item job esegue syscall, e ci sono chiamate di sistema che non possono essere interrotte.Job diventa non interrompibile fino alla conclusione del SO.
\item costo del context switch è troppo elevato
\end{itemize}
Un job J$_{i}$ è bloccato per non interrompibilità quando è  pronto per essere eseguito, ma non può perché è in esecuzione un job non interrompibile.\\ Quando si verifica questo fenomeno, si parla di inversione di priorità quando la priorità del job in esecuzione è minore di quella del job pronto per l'esecuzione. esempio: T$_{1}$ = ($\epsilon$, 4, 1, 4), T$_{2}$ = ($\epsilon$, 5, 1.5, 5), T$_{3}$ = (9, 2). Qualunque sia l'algoritmo, all'istante 0 viene messo in esecuzione job di T$_{3}$, inoltre U = 0.77 ed è schedulabile per EDF e RM, ma solo se job sono non interrompibili. Suppongo che T$_{3}$ non sia interrompibile, conclude nell'istante 2, quindi tra [$\epsilon$,2] blocca due job con priorità maggiore. Nell'intervallo tra [2, 5+$\epsilon$] eseguo 3 job, 2 di T$_{1}$ ed uno di T$_{2}$, ma non c'è abbastanza tempo e quindi T$_{2}$ manca la scadenza.\\ 
\includegraphics[scale=0.3]{images/SERT2210_3.png}\\
\\Come faccio a modellare che il job è non interrompibile, devo capire la durata massima di non interrombilità di un job: sia $\\Theta_{k}$ il tempo di esecuzione massimo della più lunga sezione non interrompibile dei job di T$_{k}$. Sia b$_{i}$(np) il tempo massimo di blocco per non interrompibilità, che è tempo subito da un job a causa dei job di priorità inferiore, quando vale? b$_{i}$(np) = max\{$\Theta_{k}$: per ogni task T$_{k}$ di priorità minore a T$_{i}$ \}: suppongo che c'è job di alta priorità rilasciato, ho sul processore job di priorità inferiore T$_{k}$ appena entrato nella sezione critica non interrompibile più lunga, subisco rallentamento di $\Theta_{k}$, ma appena finisce la sezione lo scheduler da la priorità a me, non importa quanto solo lunghe le sezioni degli altri job: caso peggiore è che vengo rilasciato quando il job che ha il $\Theta_{k}$ più lungo entra in esecuzione.\\ Il tempo massimo di blocco totale dipende da entrambe i due tempi di blocco:
b$_{i}$ = b$_{i}$(ss) + (K$_{i}$+1) $\cdot$ b$_{i}$(np). Considero numero massimo di volte per cui il job J$_{i}$ si sospende, il +1 è il fatto che la prima volta deve essere rilasciato sia che si auto-sospende che non.
\subsection{Cambi di contesto}
Come modellare rallentamenti dovuti al context switch: CS= context switch time, per ora ci metto anche tempo necessario per lo scheduler per prendere decisione.\\ Allungo il worst case del job: calcolato quando non c'è nulla che interferisce col job. worst case è e'$_{i}$ = e$_{i}$ + 2 $\cdot$ (K$_{i}$ + 1) $\cdot$ CS. job deve subire almeno due cambi di contesto: quando viene messo in esecuzione e quando viene tolto dall'esecuzione.Ma ogni volta che il job si auto-sospende  c'è un altro cambio di contesto: per essere tolto e poi per essere rimesso; K$_{i}$ = n° volte che il job si auto-sospende.\\ Alle volte non è utile modellare il context switch, però in altri casi è essenziale farlo: LST si basa sullo slack rimanente, quindi ci sono molti cambi di contesto e l'overhead è significativo ed è doveroso modellarli. Con LST è anche spesso difficile capire qual'è numero massimo di context switch di job, ma ci sono algoritmi come EDF altrettanto buoni, in un sistema real-time parametro cruciale: i job devono rispettare le scadenze; utiele vederlo in teoria ma non in pratica.
\subsection{Test di schedulabilità per job bloccanti}
Come faccio ad usare i parametri definiti nel processo di validazione: o uso test di schedulabilità o uso condizioni di schedulabilità.\\ Idea è che tempo disponibile per completare per ciascun job va diminuito del tempo massimo per cui quel job può rimanere bloccato, definisco tempo di blocco come tempo max aggiuntivo. La funzione di tempo massimo richiesto diventa:\\
w$_{i}$(t) = e$_{i}$ + b$_{i}$ + $\sum\limits_{k = 1}^{i-1}\lceil \frac{t}{p_{k}} \cdot e_{k} \rceil$ per 0 $<$ t $\leq$ min(D$_{i}$, p$_{i}$). Ho meno tempo a disposizione per completare il job, sommo b$_{i}$.\\ Stesso si applica al test di schedulabilità generale:\\
w$_{i,j}$(t) = j $\cdot$ e$_{i}$ + b$_{i}$ + $\sum\limits_{k = 1}^{i-1}\lceil \frac{t}{p_{k}} \cdot e_{k}$  per (j-1)$\cdot$ p$_{i}$ $<$ t $\leq$ w$_{i,j}$(t). non devo moltiplicare b$_{i}$ per j: il 3° job di T$_{i}$ è sempre 3$ \cdot$ e$_{i}$, ma sto cercando di capire quanto tempo rimane al 3° job, perché questo viene bloccato solo per b$_{i}$. Il blocco è qualcosa che considero soltanto quando devo studiare la schedualbilità del singolo job ed è relativa solo al singolo job. Non ha senso considerarla per tutti i task insieme, si fa sempre studio task per task.
\subsection{Condizioni di schedualbilità per task bloccanti +a priorità fissa}
Sia dato sistema di n task T ed un algoritmo a priorità fissa X, con fattore di utilizzazione U$_{X}$(n). Sappiamo che il sistema è effettivamente schedulabile se U$_{T}$ $\leq$ U$_{X}$(n), a condizione che i task non blocchino mai. Come adatto la condizione per task a priorità fissa ma che bocchino? Non posso più usare solo le condizioni di schedualbilità, perché ciascun job può bloccare con misura differente, quindi devo farlo per un task alla volta. Nel caso peggiore, ogni job di T$_{i}$ impiega un tempo e$_{i}$ + b$_{i}$ per completare l'esecuzione. Posso modellare questo tempo come tempo di esecuzione in più che il job deve subire: dato un task T$_{i}$, calcolo utilizzazione totale fino alla priorità i, dato task calcolo utilizzazione totale fino alal priorità i:\\ $\sum\limits_{k = 1}^{i}\frac{e_{k}}{p_{k}} + \frac{b_{i}}{p_{i}}$ $\leq$ U$_{X}$(i). Task di priorità inferiore non possono incidere sulla priorità del task, o meglio lo faranno solo se sono non bloccanti ma lo sto già considerando. Guardo solo ai task con priorità maggiore, considero come n° task solo fino ad i, considero solo U$_{X}$(i), man mano arriverò ad U$_{X}$(n).
Applico anche ad EDF, considero task per task, parlo in generale di densità ed uso approccio simile al precedente: task per task questo è schedualbile se:\\ $\sum\limits_{k = 1}^{n}\frac{e_{k}}{min(D_{k}, p_{k})}$ + $ \frac{b_{i}}{min(D_{i}, p_{i})}$ = $\Delta_{\tau}$ + $\frac{b_{i}}{min(D_{i}, p_{i})}$ $\leq$ 1.\\ Non sto parlando di task a priorità fissa, ogni job del sistema può avere priorità che precede il job in questione: di fatto, non posso applicare sommatoria solo a task a priorità superiore ma devo applicare a tutti i task del sistema, quindi arrivare alla densità del sistema. Alla densità contribuisce anche il task in questione che è $ \frac{e_{i}}{min(D_{i}, p_{i})}$, a cui aggiungo anche $ \frac{b_{i}}{min(D_{i}, p_{i})}$ poiché è come se il tempo di esecuzione del job del task è aumentato di b$_{i}$.\\ Problema è definire i tempi massimi di blocco se i task non hanno priorità fissata, la priorità è del job. \\ Teorema (Baker, 1991): in una schedualzione EDF un job con scadenza relativa D può bloccare un altro job con scadenza relativa D' solo se D $>$ D'.\\ Dim: se il job con scadenza relativa D blocca quello con D', vuol dire che la sua priorità è inferiore: bloccare ha il senso che un job a priorità inferiore sta togliendo tempo ad uno a priorità superiore, quindi d $>$ d' (scadenze assolute), per poter bloccare il processore deve averlo messo in esecuzione prima e quindi r $<$ r' $\Rightarrow$ D = d-r $>$ d'-r' = D'.
Ho una soluzione: posso ordinare i task per scadenze relative crescenti, ed applico la formula di b$_{i}$ per i task con priorità fissa.\\ Caso dell'auto-sospensione è difficile, quindi come realizzare il teorema di Baker? Thm non è più valido: se per esempio job J' ha priorità più alta di un job J. Se J' comincia ad eseguire e si auto-sospende: prima di tornare in esecuzione comincia job di priorità più bassa. L'ipotesi che r sia $<$ r' non è più vera, può essere dopo r' semplicemente perché il job si è autosospeso: dovrei applicare al tempo r'+tempo dopo la sospensione.\\ Posso applicare il ragionamento a r'+x'+e': di quanto tempo r può precedere r', sicuramente di x'+e'.Può non precedere r', ma r'+x'+e' è la massima distanza che posso avere fra r ed r'. Formulo teorema di Baker con auto-sospensione: in una schedulazione EDF, un job con scadenza relativa D può bloccare un altro job con scadenza relativa D' e tempo massimo di esecuzione x' solo se D $>$ D'-x'-e'.\\ Dato che entrambi i job possono auto-sospendersi, è possibile che i due task possano bloccarsi a vicenda non ho più ordinamento totale.
\subsection{Schedulazione basata su tick}
Fin'ora ho visto scheduler event-driven: viene eseguito quando si verifica un evento rilevante. In pratica, è più semplice realizzare uno scheduler time-driven, ovvero che si attiva ad interruzioni periodiche: svantaggio è che tutti i tempi nel sistema avranno granularità pari alla dimensione del mio tick.\\ Il riconoscimento di un evento come il rilascio di un job può essere differito fino al tick successivo, è come se ci fosse inversione di priorità. Definisco job pendenti, ovvero che sono stati rilasciati ma che lo scheduler non ha ancora preso in considerazione perché non è scattato il tick, e quelli eseguibili, ovvero quelli piazzati dallo scheduler, ho due code per le rispettivi due classi. Scheduler sposta job da coda dei job pendenti a coda dei job eseguibili.Quando jop termina, so già qual'è il prossimo da eseguire: sarà quello successivo nella coda dei job eseguibili. Se arriva job, questo viene messo nella coda dei job pendenti.
\subsubsection{Test schedulabilità per priorità fissa con tick}
Come posso applicare il test di schedulabilità ad uno scheduler a priorità fissa basato su tick?\\ Considero scheduler che si attiva con periodicità p$_{0}$, esegue in tempo e$_{0}$ il controllo della coda di job pendenti e con CS$_{0}$ trasforma un job da pendente a eseguibile.\\  Per controllare la schedulabilità di T$_{i}$
\begin{itemize}
\item Devo aggiungere task per controllare schedulabilità di un task T$_{0}$ = (p$_{0}$, e$_{0}$) a priorità massima.
\item Devo modellare il fatto che qundo arriva job, questo va prima o poi trasformato da pendente ad eseguibile. 
\begin{itemize}
\item per tutti i task a priorità inferiore rispetto ai job di T$_{i}$, per cui devo tenere conto del fatto che lo scheduler interverrà e trasformerà il job pendente in un job nella coda eseguibile. Oltre ai job di priorità inferiore, che vanno da i+1 a n, aggiungo un numero corrispondete di task T$_{0,k}$ = (p$_{k}$, CS$_{0}$) per ogni k = i+1,..,n, con priorità maggiore di T$_{1}$, ma che hanno periodicità CS$_{0}$, ovvero il tempo che ci mette il processore a trasformare i job in eseguibile da pendenti.
\item job a priorità superiore, aggiungo a tutti i task di priorità superiore o uguale ad (K$_{k}$ + 1) $\cdot$ CS$_{0}$, considero K$_{k}$ perché ogni volta che mi risveglio devo essere spostato da pendente ad eseguibile. Aggiungo questi valori ad e$_{k}$ per ogni k = 1,2...,i.
\end{itemize}
Perché non considero le auto-sospensione per i task a priorità inferiore? Perché task inferiore non viene mai eseguito al posto mio, pago solo il primo rilascio, perché fin quando io sono eseguibile, quelli con meno priorità di me non hanno possibilità di essere eseguiti prima di me.
\item Devo anche considerare il tempo di blocco per non-interrompibilità, anche se tutti i miei job sono sempre non interrompibili. b$_{i}$(np) = ($\lceil max_{i+1 \leq k \leq n}\frac{\Theta_{k}}{p_{0}}\rceil$ + 1) $\cdot$ p$_{0}$. max $\Theta_{k}$ moltiplicato il p$_{0}$ diventa il max di tutti i $\Theta_{k}$ di priorità inferiore, in più c'è un p$_{0}$. esempio:\\
ho lo shceduler che viene invocato con periodo p$_{0}$. Ad un certo istante viene rilasciato il job del task T$_{i}$, mi metto nel worst case, ovvero il job T$_{i}$ arriva un infinitesimo dopo che lo scheduler ha finito di controllare la coda dei job pendenti, quindi fino al prossimo p$_{0}$ non potrò eseguire il job. In questo periodo, prima che possa intervenire lo shceduler, si continua ad eseguire un job di priorità inferiore di T$_{k}$ e questo job entra nella regione interrompibile all'interno del periodo p$_{0}$ in cui è arrivato T$_{i}$, task T$_{k}$ continua l'esecuzione per un numero di periodi pari a $\frac{\Theta_{k}}{p_{0}}$. Solo quando scheduler interviene si rende conto che job di T$_{k}$ è diventato interrompibile e può entrare T$_{1}$, e c'è la parte intera superiore perché se il n° di periodi non è intero,anche la frazione non completata porta via tempo e devo aspettare comunque il periodo successivo; il +1 è il rilascio, almeno un periodo lo devo aspettare anche se non ho sezione critica, il job è arrivato prima. 
\end{itemize}
esempio: T$_{1}$ = (0.1, 4, 1, 4.5), T$_{2}$ = (0.1, 5, 1.8, 7.5), T$_{3}$ = (0, 20, 5, 19.5) non interrompibile in [r$_{3}$, r$_{3}$+1.1]. Scheduler ha p$_{0}$ = 1, e$_{0}$ = 0.05, CS$_{0}$ = 0.06.\\ Faccio analisi dei singoli task:\\
Verifico T$_{1}$: sistema equivalente è T$_{0}$ = 1,0.05), T$_{0,2}$ = (5,0.06), T$_{0,3}$ = (20,0.06), T$_{1}$ = (4,1.06), b$_{1}$ = 3.\\ w$_{1}$(t)
 = 1.06 + $\lceil \frac{t}{1}\rceil$0.05 + $\lceil \frac{t}{5}\rceil$0.06 + $\lceil \frac{t}{20}\rceil$0.06.\\
w$_{1}$(4.06) = 4.43 $\leq$ w$_{1}$(4.43) $\leq$ 4.5, quindi ok.\\
Procedo per T$_{2}$ e T$_{3}$ sempre considerando il sistema equivalente.\\ w$_{2}$(4.86) = 7.29 $\leq$ w$_{2}$(7.29) $\leq$ 7.5, quindi ok.\\
w$_{3}$(6.06) = 12.25,  w$_{3}$(12.25) = 16.53, w$_{3}$(16.53) = 19.65, w$_{1}$(19.65) = 19.8 $>$ 19.5, quindi no.\\ Devo concludere che il sistema non è validato, e va riprogettato.
\subsubsection{Condizione di schedulabilità su tick}
Per ciascun T$_{i}$ da controllare faccio quanto segue:
\begin{itemize}
\item Uso il thm Baker ed ordino per scadenze relative crescenti
\item aggiungo un task T$_{0}$ =(p$_{0}$,e$_{0}$) di massima priorità
\item Aggiungo (K$_{k}$+1)$\cdot$CS$_{0}$ al tempo i esecuzione e$_{k}$, devo farlo per tutti i task: i blocchi hanno una certa relazione ma non ho priorità fissate, quindi ogni job può portare via tempo ad un altro job nel sistema
\item Tempo di blocco è b$_{i}$(np) = ($\lceil max_{i+1 \leq k \leq n}\frac{\Theta_{k}}{p_{0}}\rceil$ + 1) $\cdot$ p$_{0}$.
\end{itemize}
Nell'esempio di prima, ottengo densità totale $\Delta$ $\simeq$ 0.95., verifico T$_{1}$: prendo $\Delta$ e sommo $\frac{3}{4}$, ovvero tempo di blocco diviso periodo di T$_{1}$. Ottengo 1.69 $>$, quindi non schedualbile. Mi posso fermare: basta trovare un task non schedulabile.
\subsection{Schedulazione priority-driven di job aperiodici}
Mi pongo il problema di dover gestire job che arrivano ad istanti di tempo non predicibili:
\begin{itemize}
\item Job aperiodici sfot-rt: non faccio nulla, voglio però che completino nel miro tempo possibile.
\item Job aperiodici hard-rt: tempi di arrivo sconosciuti, durata sconosciuta e scadenze hard.
\end{itemize}
Se non ho nessuna ipotesi su tempi di arrivo ed esecuzioni non posso prendere impegni: potrà sempre arrivare qualcosa che non mi permette di rispettare le scadenze.\\ Richiedono algoritmi differenti, però devono essere corretti ed ottimali: le scadenze vanno rispettate, i job aperiodici hard-rt va rifiutato se non è possibile garantirne le scadenze.Inoltre: tempi di risposta dei job soft-rt non hanno scadenze ma vanno minimizzato i tempi di risposta.
\subsubsection{Schedulazione di job aperiodici soft RT in background}
Metto in coda apposta e quando job è in background eseguo il job aperiodico in cima alla coda. Algoritmo è corretto, i task periodici non sono influenzati, ma non è ottimale: ritardo job aperiodici senza motivo.esempio:\\
T$_{1}$ = (3,1), T$_{2}$ = (10,4) job aperiodico A con rilascio 0.1 e durata 0.8.
\subsubsection{Schedulazione di job aperiodici soft RT interrupt-driven}
Esegui job aperiodici nel mo,mento in cui li rilasci, algortimo non è corretto ma è ottimo: job aperiodici finiscono nei tempi minimi, ma task periodici possono mancare le scadenze.
\subsubsection{Schedualzione di job aperiodici soft RT con slack stealing}
Algoritmo esegue i job aperiodici in anticipo rispetto a quelli periodici finché c'è uno slack globale positivo.\\ È corretto perché i job periodici non perdono le scadenze. È ottimale, solo per job aperiodico in cima alla coda. Svantaggio è che tenere uno slack globale in uno scheduler priority divern è difficile.
Job aperiodico riprende quando lo slack torna positivo.
\subsubsection{Schedulazione di job aperiodici soft RT con polling}
Algoritmo basato su polling, ovvero nel sys di task periodici introduco server di polling, a cui do un certo periodo p$_{s}$ e tempo di esecuzione e$_{s}$ e gli do priorità massima,così da ridurre i tempi di risposta dei job aperiodici. Server controlla coda job aperiodici, se vuota si auto-sospende fino a prossimo tick, altrimenti esegue per al più
e$_{s}$ unità di tempo, per poi auto-sospendersi.\\ È corretto se dimensiono il poller in modo tale che il suo fattore di utilizzazione non ecceda quello dell'algoritmo di schedulazione;come aggiungere un task periodico. \\ Non è ottimale, job aperiodico può arrivare subito dopo esecuzione del poller. Nell'esempio forse potevo anticipare l'esecuzione del job A senza far mancare le scadenze. Posso migliorare le capacità del server? Sì.
\end{document}
