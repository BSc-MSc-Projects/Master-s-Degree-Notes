\contentsline {chapter}{\numberline {1}Hardware Insights}{4}{}%
\contentsline {section}{\numberline {1.1}Introduzione - dettagli hardware}{4}{}%
\contentsline {subsection}{\numberline {1.1.1}Primo esempio: Bakery algorithm di Lamport}{5}{}%
\contentsline {subsection}{\numberline {1.1.2}Scheduling e parallelismo}{6}{}%
\contentsline {subsection}{\numberline {1.1.3}Pipeline}{7}{}%
\contentsline {subsection}{\numberline {1.1.4}Processori moderni}{9}{}%
\contentsline {section}{\numberline {1.2}La pipeline nell'x86}{9}{}%
\contentsline {subsection}{\numberline {1.2.1}Intel x86 superscalar pipeline}{10}{}%
\contentsline {subsubsection}{Istruction span problem}{11}{}%
\contentsline {subsection}{\numberline {1.2.2}Pipeline OOO speculativa}{11}{}%
\contentsline {subsubsection}{Eccezioni imprecise}{12}{}%
\contentsline {subsection}{\numberline {1.2.3}Algoritmo di Robert Tomaluso}{13}{}%
\contentsline {subsubsection}{Renamed registers}{13}{}%
\contentsline {subsubsection}{Reservation stations}{14}{}%
\contentsline {subsubsection}{CDB e ROB}{14}{}%
\contentsline {subsubsection}{Schema architetturale}{15}{}%
\contentsline {subsubsection}{Storia}{16}{}%
\contentsline {subsection}{\numberline {1.2.4}Ancora sul memory wall}{16}{}%
\contentsline {subsection}{\numberline {1.2.5}OOO nell'x86}{16}{}%
\contentsline {subsubsection}{Hyper-threading}{17}{}%
\contentsline {subsection}{\numberline {1.2.6}Gestione degli interrupt}{17}{}%
\contentsline {subsection}{\numberline {1.2.7}Trap e stadi della pipeline}{18}{}%
\contentsline {subsection}{\numberline {1.2.8}Meltdown attack}{19}{}%
\contentsline {paragraph}{Side channel:}{20}{}%
\contentsline {subsection}{\numberline {1.2.9}Dettagli di x86 64 bit - Instruction Set}{20}{}%
\contentsline {subsubsection}{Meltdown in assembly}{21}{}%
\contentsline {subsection}{\numberline {1.2.10}Contromisure per meltdown}{21}{}%
\contentsline {section}{\numberline {1.3}Branches}{22}{}%
\contentsline {subsection}{\numberline {1.3.1}Multiple bits predictors}{23}{}%
\contentsline {subsection}{\numberline {1.3.2}Altre soluzioni per branch predictors}{24}{}%
\contentsline {subsubsection}{Predittore correlato(m,n) a due livelli}{25}{}%
\contentsline {subsubsection}{Tournament predictor}{25}{}%
\contentsline {subsection}{\numberline {1.3.3}Salti indiretti}{26}{}%
\contentsline {subsection}{\numberline {1.3.4}Attacchi spectre}{26}{}%
\contentsline {subsubsection}{Spectre v1 (spectre prime}{26}{}%
\contentsline {subsubsection}{Spectre v2}{27}{}%
\contentsline {subsubsection}{Come bypassare spectre v2}{28}{}%
\contentsline {subsubsection}{esempio: codice per spectre}{28}{}%
\contentsline {subsection}{\numberline {1.3.5}Loop unrolling}{29}{}%
\contentsline {section}{\numberline {1.4}Aspetti esterni al processore in una architettura IT}{29}{}%
\contentsline {subsection}{\numberline {1.4.1}Multi processori}{29}{}%
\contentsline {subsection}{\numberline {1.4.2}Architettura NUMA (Non Uniform Memory Access)}{30}{}%
\contentsline {section}{\numberline {1.5}Coerenza delle cache}{31}{}%
\contentsline {subsection}{\numberline {1.5.1}Definizione della coerenza}{31}{}%
\contentsline {subsubsection}{Cache write through e write back con le consistenze}{31}{}%
\contentsline {subsection}{\numberline {1.5.2}Protocolli di consistenza}{32}{}%
\contentsline {subsubsection}{Snooping cache}{33}{}%
\contentsline {subsubsection}{MSI protocol}{33}{}%
\contentsline {subsubsection}{Protocollo MESI}{34}{}%
\contentsline {subsubsection}{MOESI}{35}{}%
\contentsline {subsubsection}{Implementazioni in x86}{35}{}%
\contentsline {subsubsection}{Alternativa allo snooping}{35}{}%
\contentsline {paragraph}{Funzionamento della directory:}{35}{}%
\contentsline {subsection}{\numberline {1.5.3}Relazione fra software e performance della cache}{36}{}%
\contentsline {subsection}{\numberline {1.5.4}Insepction cache line access}{37}{}%
\contentsline {subsubsection}{High resolution timer per x86}{37}{}%
\contentsline {subsubsection}{Cache line flush}{37}{}%
\contentsline {subsection}{\numberline {1.5.5}ASM inline}{38}{}%
\contentsline {subsection}{\numberline {1.5.6}Inspection cache senza RDTSC}{39}{}%
\contentsline {subsection}{\numberline {1.5.7}Nota: inclusività della cache}{39}{}%
\contentsline {section}{\numberline {1.6}Memory concistency}{40}{}%
\contentsline {subsection}{\numberline {1.6.1}Sequencial consistency}{40}{}%
\contentsline {subsection}{\numberline {1.6.2}Total Store Order}{41}{}%
\contentsline {subsection}{\numberline {1.6.3}Sincronizzazione della memoria in x86}{41}{}%
\contentsline {paragraph}{gcc built-in}{42}{}%
\contentsline {subsubsection}{Esempi di implementazione}{42}{}%
\contentsline {subsection}{\numberline {1.6.4}Locks contro coordinazione scalabile}{43}{}%
\contentsline {subsubsection}{Linearizzabilità}{43}{}%
\contentsline {section}{\numberline {1.7}Approccio di RCU}{47}{}%
\contentsline {subsection}{\numberline {1.7.1}Kernel level RCU}{48}{}%
\contentsline {subsection}{\numberline {1.7.2}Preemptable RCU}{48}{}%
\contentsline {section}{\numberline {1.8}Aspetti ulteriori di parallelismo}{49}{}%
\contentsline {subsection}{\numberline {1.8.1}Vettorizzazione su x86}{49}{}%
\contentsline {subsection}{\numberline {1.8.2}Allineamento della memoria}{49}{}%
\contentsline {chapter}{\numberline {2}Kernel programming basics}{51}{}%
\contentsline {section}{\numberline {2.1}Addressing}{51}{}%
\contentsline {subsection}{\numberline {2.1.1}Linear addressing}{51}{}%
\contentsline {subsection}{\numberline {2.1.2}Segmentazione}{51}{}%
\contentsline {subsection}{\numberline {2.1.3}Memoria virtuale}{51}{}%
\contentsline {subsection}{\numberline {2.1.4}Processori di sistema e segmentazione}{52}{}%
\contentsline {subsubsection}{Segment selector}{52}{}%
\contentsline {section}{\numberline {2.2}Accesso in memoria su x86}{52}{}%
\contentsline {subsection}{\numberline {2.2.1}x86 protected mode}{53}{}%
\contentsline {subsection}{\numberline {2.2.2}x65 protected mode}{53}{}%
\contentsline {subsection}{\numberline {2.2.3}Tabella di segmentazione}{53}{}%
\contentsline {subsection}{\numberline {2.2.4}Segmentazione e paginazione}{54}{}%
\contentsline {subsection}{\numberline {2.2.5}Protezione nella segmentazione}{54}{}%
\contentsline {subsubsection}{Protection GATEs}{54}{}%
\contentsline {subsection}{\numberline {2.2.6}Ring model in x86}{55}{}%
\contentsline {subsubsection}{Registri di segmento}{55}{}%
\contentsline {subsection}{\numberline {2.2.7}GDT di x86}{56}{}%
\contentsline {subsubsection}{Accesso alla GDT}{56}{}%
\contentsline {subsection}{\numberline {2.2.8}Code e data segment per Linux}{57}{}%
\contentsline {subsubsection}{Versione a 64 bit, long mode}{58}{}%
\contentsline {subsection}{\numberline {2.2.9}Gestione dei selettori in x86}{58}{}%
\contentsline {subsection}{\numberline {2.2.10}GDT estesa in Linux}{58}{}%
\contentsline {subsection}{\numberline {2.2.11}TSS}{58}{}%
\contentsline {subsubsection}{Come arrivare al TSS}{59}{}%
\contentsline {subsection}{\numberline {2.2.12}Replicazione della GDT}{59}{}%
\contentsline {subsubsection}{Gestione della per-CPU memory in Linux}{60}{}%
\contentsline {subsection}{\numberline {2.2.13}Thread Local Storage}{60}{}%
\contentsline {section}{\numberline {2.3}Internals di x86}{60}{}%
\contentsline {subsection}{\numberline {2.3.1}Registri di controllo x86}{60}{}%
\contentsline {subsection}{\numberline {2.3.2}Trap ed Interrupt}{61}{}%
\contentsline {subsection}{\numberline {2.3.3}Dettagli generali sulla gestione di GATE e segmenti}{61}{}%
\contentsline {subsubsection}{Dettagli sui GATE}{62}{}%
\contentsline {subsection}{\numberline {2.3.4}Dettagli in Linux}{62}{}%
\contentsline {section}{\numberline {2.4}Versioni del kernel Linux}{63}{}%
\contentsline {subsection}{\numberline {2.4.1}System call indexing}{63}{}%
\contentsline {subsection}{\numberline {2.4.2}Acceso a syscall livello user}{63}{}%
\contentsline {subsubsection}{Formato delle syscall}{64}{}%
\contentsline {subsection}{\numberline {2.4.3}UNISTD\_32 ed UNISTD\_64}{64}{}%
\contentsline {subsection}{\numberline {2.4.4}Passaggio di parametri al kernel}{65}{}%
\contentsline {section}{\numberline {2.5}Introduzione delle syscall nel kernel}{65}{}%
\contentsline {paragraph}{Setup degli MSR in Linux}{66}{}%
\contentsline {subsection}{\numberline {2.5.1}Costrutto syscall}{67}{}%
\contentsline {subsection}{\numberline {2.5.2}System call table}{67}{}%
\contentsline {section}{\numberline {2.6}Il vero dispatcher}{68}{}%
\contentsline {paragraph}{swapgs}{68}{}%
\contentsline {subsection}{\numberline {2.6.1}Kernel 4}{68}{}%
\contentsline {subsection}{\numberline {2.6.2}Attacco spwags}{69}{}%
\contentsline {subsubsection}{Contromisure}{70}{}%
\contentsline {subsection}{\numberline {2.6.3}VDSO}{70}{}%
\contentsline {subsection}{\numberline {2.6.4}Situazione attuale su Linux}{70}{}%
\contentsline {section}{\numberline {2.7}Organizzazione del kernel Linux}{70}{}%
\contentsline {subsection}{\numberline {2.7.1}Kernel compiling}{71}{}%
\contentsline {paragraph}{Initrd}{71}{}%
\contentsline {subsection}{\numberline {2.7.2}System-map}{72}{}%
\contentsline {subsection}{\numberline {2.7.3}Altri esempi}{72}{}%
\contentsline {chapter}{\numberline {3}Kernel level memory management}{74}{}%
\contentsline {section}{\numberline {3.1}Boot e memory management}{74}{}%
\contentsline {subsection}{\numberline {3.1.1}Informazioni basiche sul boot}{74}{}%
\contentsline {subsubsection}{Gestione della memoria}{75}{}%
\contentsline {subsection}{\numberline {3.1.2}Mappatura tradizionale di x86}{75}{}%
\contentsline {subsubsection}{Setup iniziale}{76}{}%
\contentsline {subsection}{\numberline {3.1.3}Strutture dati per la gestione della memoria}{77}{}%
\contentsline {section}{\numberline {3.2}Kernel page table}{78}{}%
\contentsline {section}{\numberline {3.3}Nodi di memoria (UMA vs NUMA)}{78}{}%
\contentsline {subsection}{\numberline {3.3.1}Memblock}{78}{}%
\contentsline {section}{\numberline {3.4}Supporto alla paginazione in x86}{79}{}%
\contentsline {subsection}{\numberline {3.4.1}Page table in i386}{79}{}%
\contentsline {subsubsection}{Startup in Linux}{80}{}%
\contentsline {subsection}{\numberline {3.4.2}Come Linux gestisce i386}{80}{}%
\contentsline {subsection}{\numberline {3.4.3}Entry di una page table x86}{81}{}%
\contentsline {subsection}{\numberline {3.4.4}PAE}{83}{}%
\contentsline {subsection}{\numberline {3.4.5}Gestione della paginazione x86\_64}{83}{}%
\contentsline {subsubsection}{Page tables in x86\_64}{84}{}%
\contentsline {subsubsection}{Page mapping direct e non-direct}{84}{}%
\contentsline {subsubsection}{Hige Pages}{84}{}%
\contentsline {subsubsection}{L1 TF}{85}{}%
\contentsline {subsection}{\numberline {3.4.6}Raggiungere ed allocare/de allocare memoria}{85}{}%
\contentsline {subsubsection}{Buddy allocator}{86}{}%
\contentsline {subsubsection}{Buddy allocator in Linux}{86}{}%
\contentsline {paragraph}{Zone di memoria}{86}{}%
\contentsline {subsection}{\numberline {3.4.7}Organizzazione in NUMA ed allocazione}{87}{}%
\contentsline {subsubsection}{API per buddy allocator}{87}{}%
\contentsline {subsection}{\numberline {3.4.8}Caso di allocazione/de-allocazione di strutture dati specifiche}{88}{}%
\contentsline {subsubsection}{Quicklist API}{89}{}%
\contentsline {subsection}{\numberline {3.4.9}Allocatore SLAB}{89}{}%
\contentsline {subsection}{\numberline {3.4.10}Allocazione di area di memoria grande}{90}{}%
\contentsline {subsubsection}{kmalloc vs vmalloc}{90}{}%
\contentsline {subsubsection}{Rimappatura delle page table}{90}{}%
\contentsline {section}{\numberline {3.5}Operazioni sul TLB}{91}{}%
\contentsline {subsection}{\numberline {3.5.1}Lavorare sul TLB in Linux ed x86}{91}{}%
\contentsline {chapter}{\numberline {4}Cross ring data move}{93}{}%
\contentsline {section}{\numberline {4.1}Segmentation based protection breaks}{93}{}%
\contentsline {subsection}{\numberline {4.1.1}Gestione dei pointers}{93}{}%
\contentsline {subsection}{\numberline {4.1.2}Segmentazione flessibile}{93}{}%
\contentsline {subsection}{\numberline {4.1.3}Segmentazione constraint}{94}{}%
\contentsline {subsubsection}{Meccanismo in Linux}{95}{}%
\contentsline {subsubsection}{API del kernel per eseguire operazioni di memoria}{95}{}%
\contentsline {subsection}{\numberline {4.1.4}Caso della syscall read o write nel kernel Linux}{96}{}%
\contentsline {subsection}{\numberline {4.1.5}memcpy con i pointers}{96}{}%
\contentsline {subsubsection}{SEGFAULT mascherati}{97}{}%
