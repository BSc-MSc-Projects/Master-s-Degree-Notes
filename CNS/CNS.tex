\documentclass[16px]{article}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}

\begin{document}
\tableofcontents
\section{Introduzione-warm up example}
Il problema spesso è che una buona crittografia è applicata male alla risoluzione di un problema.esempio: paper che discute di una tecnica di sicurezza ed in cui viene matematicamente provata la sicurezza.\\ Basata sul meccanismo del One Time Pad: ho il mio plain text e voglio criptarlo in modo che non si capisca cosa ci sia scritto. Genero una sequenza random di bit, di lunghezza pari alla lunghezza del testo. Una volta ottenuta la chiave, computo lo XOR fra la chiave ed il plaintext ed ottengo il mio ciphertext.\\ Il seguente meccanismo è il migliore possibile per fare enrcyption.\\ Per decriptare applico il procedimento inverso, facendo sempre l'XOR, infatti: b $\oplus$ 1 = $\overline{b}$ $\oplus$ 1 = b.\\ Devo però fare delle assunzioni:
\begin{enumerate}
\item Per ogni nuovo messaggi, devo usare una diversa chiave. Questo perché, se ripetessi la chiave avrei il peggior meccanismo di enrcyption: se ho due messaggi M$_{1}$ ed M$_{2}$, ed ottengo C$_{1}$ = M$_{1}$ $\oplus$ K e C$_{2}$ = M$_{2}$ $\oplus$ K, ora facendo C$_{1}$ $\oplus$ C$_{2}$ = (M$_{1}$ $\oplus$ K) $\oplus$ (M$_{2}$ $\oplus$ K) = M$_{1}$ $\oplus$ M$_{2}$ (in quanto K $\oplus$ K si elide).Conoscendo uno dei due messaggi posso ricavare l'altro.
\item La chiave deve essere lunga quanto il plaintext
\item La chiave deve essere veramente random, e non pseudorandom.
\end{enumerate}
L'algoritmo introdotto sopra è chiamato Vernam Cipher, ed è il miglior meccanismo di enrcyption possibile.\\ Il problema nel metterlo in pratica è che la chiave deve essere nota sia a chi produce il messaggio, sia a chi lo riceve, quindi va trasmessa su un canale sicuro. Se le dimensioni della chiave cominciano a diventare considerevoli, ad esempio per 2GB di plaintext devo avere 2GB di chiave, il costo d'invio al receiver diventa oneroso.\\ Quando si parla di sicurezza, non bisogna chiedersi come rendere il sistema sicuro, ma da cosa devo difendermi, di cosa è capace l'attaccante.\\ OTP protegge la confidenzialità, ma non garantisce l'integrità.\\ Le 3 proprietà che posso/voglio garantire sono:
\begin{itemize}
\item Confidenzialità: proteggo i dati da persone esterne,che non possono leggere il contenuto senza una chiave
\item Integrità: voglio che i miei dati rimangano inalterati
\item Aviability: mi proteggo, ad esempio da DDoS
\end{itemize}
Nel caso di OTP, l'integrità non è garantita: se un avversario prende il mio messaggio e lo cambia,ad esempio flippando alcuni byte (Man in the middle attack) non riesco a rendermene conto; l'avversario ha agito sul testo cifrato, senza interessarsi del,contenuto.
\section{Encryption}
Servizio di sicurezza che vuole proteggere la confidenzialità dei dati, non protegge però l'integrità. Si parte dal plaintext $\longrightarrow$ encryption $\longrightarrow$ cipher text $\longrightarrow$ invio $\longrightarrow$ decryption $\longrightarrow$ plaintext.\\ Servono delle chiavi per potere de/criptare, per ora mi concentro sul meccanismo della symmetric key: sia sender che receiver usano la stessa chiave. Il cipher sarà il mio algoritmo per criptare e decriptare:\\
C = ENC(K,P) D = DEC(K,C).
\subsection{Esempi storici di cipher}
Un primo esempio può essere quello di sostituire le lettere del plaintext con altre lettere, in maniera reversibile ovvero se a $\longrightarrow$ b, non posso avere c $\longrightarrow$ b.\\ Posso decriptare in maniera veloce? Vedo la frequenza delle lettere di una lingua, ad esempio l'italiano, e saprò quali lettere compaiono più spesso in un plaintext, inoltre posso avere delle parole con delle ripetizioni interne.\\ Procedo per tentativi, nel momento in cui deduco una lettera, la associo ad una più o meno probabile.\\ Posso inoltre ricavare la chiave usata per criptare.\\ Il metodo è storico (me pare addirittura lo usavano i romani sotto Cesare),  quindi fortemente sconsigliato.
\subsection{RFID mutual authentication}
Vernam cipher è il miglior meccanismo, ma ha delle forti implicazioni. Considero una situazione reale:\\ ho un TAG, ed un reader presso cui devo autenticarmi. Il TAG ha lo scopo di provare al reader che l'utente è davvero reale, ma anche il reader dovrebbe dimostrare di essere sicuro; voglio quindi che l'autenticazione sia mutua.\\ Ho un segreto S, scritto ad esempio in una mia carta d'autenticazione e quando mi approccio al reader mi devo identificare. Ho due probelmi:
\begin{itemize}
\item La trasmissione avviene su un canale wireless, se poi la trasmissione è in chiaro un attacker può captare e rubare S
\item Se il reader è falso, ora conosce il mio segreto S
\end{itemize}
Vorrei poter autenticarmi senza mostrare il segreto S esplicitamente, uso uno schema:\\ il TAG ha un segreto S,statico, ed una chiave temporanea k. Invece di trasmettere S, invio k $\oplus$ S al reader, che avrà un database in cui ha il segreto salvato e la chiave k. Il reader riesegue quindi lo XOR e vede se il risultato coincide con quello che gli ho inviato io. La prossima chiave sarà generata dal reader a partire da k, quindi con un meccanismo pseudorandom. Provo ad usare un former analyzer, che mi garantisce che il sistema è sicuro (software che prova a crackare il meccanismo di encryption). Sono realmente sicuro?\\ Ho l'operazione k $\oplus$ S, k è pseudorandom e posso avere due situazioni:
\begin{enumerate}
\item S è la chiave: sto violando la proprietà 1, in quanto riuso S più volte per messaggi diversi
\item k è la chiave: se faccio (S $\oplus$ k$_{i}$) $\oplus$ (S $\oplus$ k$_{i+1}$) = k$_{i}$ $\oplus$ k$_{i+1}$. Non ho violato il sistema, ma ho la combinazione delle due chiavi, che sono pseudorandom: ho x $\oplus$ f(x) (PNRG(x)), x dipende da f(x), quindi posso fare un ciclo fino al valore massimo, controllo se z$_{i}$ = x$_{i}$ $\oplus$ PNRG(x$_{i}$), alla fine ricaverò k$_{i}$.
\end{enumerate}
Il microfono non può essere risolto in alcun modo, le assunzioni erano errate, quindi:
\begin{itemize}
\item Former analyzers non sono una certezza, bisogna comunque verificare che l'assunzione è corretta
\item Random e pseudorandom sono completamente diversi
\end{itemize}
\subsection{Sicurezza di un cipher}
Un cipher è sicuro quando:
\begin{itemize}
\item protegge la confidenzialità
\item nasconde i messaggi
\item non può essere violato
\end{itemize}
Ma questa definizione è una supercazzola (serio, così ha detto il prof a lezione e così scrivo io negli appunti), e anche altre definizioni sono brutte e sbagliate.
Un cipher può essere sicuro per un determinato attacco che vuole svelare il contenuto, ma non sicuro per un altro che vuole vedere solo parte delle coppie plaintext-ciphertext.\\ Ad esempio un chosen plaintext attack permette di vedere sia plaintext che ciphertext, voglio essere robusto quantomeno a questo tipo di attacco.\\ Definizione di semantically secure o IND-CPA, ovvero Indistinguishability Under Chosen Plaintext Attack. \\ esempio: ho due messaggi, M$_{0}$ ed M$_{1}$, suppongo di poter criptare solo uno dei due. \\ Permetto all attacker di mandarmi i due messaggi ed io scelgo a caso quale dei due criptare con un coinflip. Mando indietro il messaggio cifrato all'attaccante: in condizioni normali l'attacante può facilmente decriptare il messaggio, se usassi un cipher non semantically secure, ma ora entra in gioco IND-CPA $\Rightarrow$ l'attaccante ha una probabilità del 50\% di ottenere il messaggio corretto, ovvero deve scegliere a caso fra i due.I sistema sarà semantically secure se l'avversario non può risolvere questa situazione: ha a disposizione un oracolo, che gli fornisce l'encryption dei due messagi, quindi se uso un meccanismo di encryption sostitutivo (vedi esempio de Giulio Cesare) $\Rightarrow$ GAME OVER. Ora uso una chiave random (esempio Vernam Cipher): allo stesso plaintext corrispondono ciphertext diversi, quindi l'oracolo non può fornire il risultato esatto all'attaccante. L'unico modo che ha per vincere è di tirare ad indovinare, quindi con un coinflip.\\ L'encryption deve essere random, perché se una sotto stringa si ripete non deve corrispondere allo stesso ciphertext. Lo XOR è random: \\
bit segreto $\oplus$ bit random\\
bit segreto: 0 = p, 1 = 1-p\\ 
bit random: 0 = $\frac{1}{2}$, 1 = $\frac{1}{2}$\\
Avrò quindi: \\
\begin{table}
\begin{tabular}{||c c c c||}
\hline\hline
bit segreto & bit random & XOR & probabilità \\
\hline
0 & 0 & 0 & $\frac{p}{2}$\\
\hline
0 & 1 & 1 & $\frac{p}{2}$\\
\hline
1 & 0 & 1 & $\frac{(1-p)}{2}$\\
\hline
1 & 1 & 0 & $\frac{(1-p)}{2}$\\
\end{tabular}
\end{table}
Quindi il Vernam ciper è perfettamente random: l'avversario vede solo il cipher text, quindi può indovinare 0 o 1 con probabilità: $\frac{p}{2}$ + $\frac{(1-p)}{2}$ = $\frac{1}{2}$.
Vernam cipher è però teorico e nella pratica si usano altri cipher, divisi in categorie:
\begin{itemize}
\item stream cipher: un mimic di Vernam cipher, usa un algoritmo pseudorandom usando lo XOR, il più famoso era RC4, oggi si usano Salsa20 e ChaCha20.
\item Block cipher: il più usato è AES, usano una tecnica diversa
\item Block cipher in stream mode: AES-CTR, il block cipher genera una chiave pseudorandom e poi usa uno stream cipher.
\end{itemize}
\subsection{Stream cipher}
L'obbiettivo è quello di approssimare One Time Pad: invece di usare una chiave random, uso una chiave di 128 bit come seed per uno stream di bit pseudorandom, che sarà il keystream.\\ Usa poi lo XOR, la chiave è più corta e viene incrementata con il keystream: l'algoritmo pseudorandom è progettato ad hoc, non è il classico pseudorandom. La differenza cruciale con OTP è che la chiave è generata a partire da una chiave k piccola, quindi posso trasmettere k al receiver facilmente. Ma se k è sempre la stessa ho un problema, ovvero encrypto sempre con la stessa key di base. Se una sottostringa si ripete, avrò ciphertext diverso (la periodicità del sistema pseudorandom deve essere molto lunga), ma per lo stesso messaggio ho lo stesso ciphertext, in quanto l'algoritmo pseudorandom  deterministico. Vorrei comunicare la chiave una volta per tutte senza doverla cambiare (come avviene in Wi Fi access point), ho una chiave k piccola ed un keystream lungo, ma non sono IND-CPA.
\subsubsection{Initialization vector}
Ho un plaintext che voglio cifrare, mando un messaggio alla mia NIC in modo che lo encrypti con un algoritmo di tipo stream cipher. La NIC ha una chiave k a lungo termine e quando riceve il messaggio genera una quantità dinamica,che è l'initialization vector (IV); questa quantità può essere truly random. Il seed sarà generato giustapponendo la chiave k all'IV, che mi fornirà il keystream, ovviamente l'IV deve essere diverso per ogni messaggio. Come comunico all'altro end l'IV? Lo mando in chiaro con il messaggio, se lo strem cipher è buono non posso determinare il messaggio a partire dall'initialization vector. Ora il receiver può riprodurre il keystream: fa lo XOR e decripta il messaggio ricevuto; l'ipotesi fondamentale è che il PRNG sia buono.\\ Ho la prova di essere semantically secure se l'IV non si ripete.
\subsubsection{Case study: WEP 802.11}
Wired Equivalent Privacy, standardizzato nel 1997-1999 dagli stessi progettisti di Wi-Fi. Aveva 3 obbiettivi:
\begin{itemize}
\item confidenzialità: proteggere i pacchetti da qualcuno di esterno alla rete, uso dell'algoritmo stream cipher RC4 (poi scoperto vulnerabile, ma è n'altra storia).
\item integrità: il pacchetto non doveva essere modificato lungo il tragitto.
\item: autenticazione: voglio che qualcuno possa entrare nella rete solo tramite delle credenziali.
\end{itemize}
\subsubsection{RC4}
Algoritmo PRNG specifico, usato per generare il keystream. Oggi è considerato debole, ma comunque WEP avrebbe avuto gli stessi problemi anche se fosse stato buono.\\ ENC(KEY,MSG) = MSG $\oplus$ RC4(KEY,IV)\\ L'IV va generato per ogni frame e deve essere diverso per ognuno di essi, inoltre lo stream cipher deve essere sincronizzato in un canale che ha perdita. L'IV viene trasmesso in chiaro, se lo stream cipher è buono è buono non ho problemi. WEP è sicuro se l'IV non si ripete, altrimenti userei la stessa chiave e non avrei semantic security.\\ In Wi-Fi è "semplice" attaccare con Chosen Plaintext Attack o Known Plaintext Attack, anche se non conosco i messaggi ma li vedo in XOR posso ricavare qualcosa, l'IV è quindi cruciale e in WEP furono commessi due errori:
\begin{itemize}
\item La taglia era di 24 bit, molto piccola: circa 16.7 milioni di encryption diversi, se assumo 1500 byte di trama, con 7 Mbps di thoughput $\Rightarrow$ riciclo dopo appena 8 ore.
\item L'implementazione fu lasciata libera $\Rightarrow$ COSA DA NON FARE MAI, MAIIIII M A I (MAI PIÙÙÙÙÙÙÙÙÙÙ NON NOMINARE MIA MADRE CIT*), potrebbero metterci tutti 00..0 se non leggono la specifica.
\end{itemize}
Inoltre, conviene generare l'IV random o in maniera sequenziale? Se lo genero random, ho il 50\% di probabilità di avere un duplicato dopo circa 4000 frame (birthday paradox).Meglio quindi sceglierli in serie, però sono suscettibile ad un attacco: se il router viene spento e riacceso, la sequenza riparte da 0. L'attacker può catturare i messaggi, rebootare di nuovo e fare un Chosen Plaintext Attack, ricreando la sequenza degli IV.\\ Il reboot dovrebbe prevedere un seed sempre diverso, ma qui il generatore è PRNG.\\ L'attacker può quindi creare un dizionario:\\ per ogni IV avrà il corrispondente keystream = RC4(IV,K), così da poter usare la coppia per attaccare (manda un contenuto noto ed una volta ricevuta la risposta ricava MSG $\oplus$ keystream $\oplus$ MSG ed ottiene il keystream).\\ Se RC4 è buono, non deve essere possibile ricavare una entry del dizionario avendo tutte le restanti. Un altro attacco può consistere nell'aspettare che l'IV si ripeta.
\subsubsection{User authentication}
Autenticazione: mostrare davvero chi sei. Non va confusa con l'identificazione, con cui fornisco nome cognome etc..., l'autenticazione è la prova che controllo la mia identità digitale.\\ Non è semplice definire l'autenticazione, molti siti difatti permettono di creare ad esempio mail che non mostrano il mio nome e cognome e quindi questo non mi identifica, ma voglio comunque che l'account sia usato da una sola persona.\\ Metodi di autenticazione:
\begin{itemize}
\item Metodo "base": una password, un pin, chiave segreta etc...
\item device fisici: smart card, token digitali, hardware non clonabile.
\item biometrics: impronta digitale, retina etc...
\item behavioural authentication: registrazione vocale, hand writing etc...
\end{itemize}
In WEP non fu prevista l'autenticazione di ogni singolo utente. L'obiettivo era quello di riuscire ad autenticare un gruppo di persone che potessero entrare nella rete. L'idea: chi sta nella stessa rete può essere visto dagli altri, quindi usa los etsso meccanismo di enrcyption.\\ Il grant di accesso era dato solo a chi aveva una password comune, pre-distribuita. Come provare l'autenticazione: non posso inviarla in chiaro (sono in Wi-Fi), quindi in WEP venne introdotto un meccanismo che prevedeva di effettuare delle operazioni sulla password; il risultato non doveva dare informazioni sulla password.\\ Meccanismo: conosco k, l'access point mi manda una challenge ed io gli fornisco un encryption della challenge e della password.Per ogni nuovo utente devo usare una challenge diversa, può seere una stringa in plaintext, in WEP era di 128 bit. Una volta ricevuta la risposta, l'AP decriptava e se il risultato era la k dava l'accesso.Tecnica symmetric key, buona? Sì, trovo in un libro scritto da gente top nel settore che mi descrive esattamente questa tecnica, se la challenge è random e senza ripetizioni sono al sicuro.\\ In WEP non è così,anzi l'autenticazione aiuta a violare la confidenzialità: come detto sopra, posso effettuare un Known Plaintext Attack per creare un dizionario IV | keystream = RC4(K,IV). Quello che vedo nel messaggio è chipertext = plaintext $\oplus$ keystream, devo conoscere il plaintext. WEP fornisce la possibilità di un KPA con l'autenticazione: CT $\oplus$ challenge = RC4(k, IV) = keystream. L'approccio è corretto, ma viene riusata la stessa chiave per cifrare la challenge ed i messaggi. La challenge inoltre è in plaintext $\longrightarrow$ nota $\longrightarrow$ Known Plaintext Attack.\\ Attacker si finge l'access point ed inviando challenge false costruisce il dizionario, una volta ottenuto il keystream (user mi manda challenge $\oplus$ keystream, io ho la challenge, faccio $\oplus$ ed ottengo il keystream) posso usarlo per criptare la challenge successiva e ottenere l'accesso.\\ L'autenticazione era certificata come robusta, ma l'implementazione non lo era, inoltre l'IV era lasciato all'implementatore $\Rightarrow$ MAI FARLO.\\ Il fix fu di far scegliere sia la challenge che l'IV all'acces point, ma in ogni caso essendo l'IV corto si sarebbe ripetuto.
\subsection{Integrità}
Per l'integrità, l'idea fu quella di utilizzare CRC-32, il controllo a lvl2, come integrity check. Non è certo però che funzioni, ma l'attacker vedrà solo il ciphertext, quindi anche se il CRC-32 non è buono è protetto dall'encryption: assunzione errata. Confidenzialità non garantisce integrità. CRC-32 è lineare rispetto allo XOR: se faccio CRC32(A) e CRC(32) di B (con A e B due messaggi diversi) fare CRC32(A $\oplus$ B) = CRC32(A) $\oplus$ CRC32(B). Inoltre, lo XOR era proprio usato per l'encryption $\Rightarrow$ deadly. Ogni messaggio può subire modifiche o injection: \\
ho un plaintext M di, cui l'attacker vuole flippare 3 bit, ho CRC32(M), ed ho M $\oplus$ RC4(K,IV). Produco un messaggio $\delta$ che è uguale ad M, ma con i 3 bit che voglio flippare pari ad 1, computo CRC32($\delta$), prendo il precedente ciphertext e ne faccio lo XOR con il mio:\\
keystream $\oplus$ M $\oplus$ $\delta$ | keystream$_{2}$ $\oplus$ CRC(M $\oplus$ $\delta$) (per linearità dello XOR).\\ Ho un nuovo messaggio valido (nelle ipotesi che $\delta$ sia pari ad M), quindi posso eseguire un Man in the middle attack.\\
Dopo WEP ci fu 802.11 in cui il protocollo è WPA (anche WPA2 con AES), venne inoltre eseguita una patch firmware a RC4:
\begin{itemize}
\item IV a 48 bit
\item protezione dell'IV
\item etc...
\end{itemize}
Morale: rivolgersi ad un esperto di crittografia.
\section{Autenticazione in generale}
Le password sono deboli, faccio una panoramica per capire se una password è hard o no. Autenticazione: provo che ho una password, che per ora ritengo analoga ad un segreto (in pratica: un segreto è una stringa random). Se ho 4 bit, ho $2^4$ possibilità, quindi la probabilità di indovinare al primo tentativo è $\frac{1}{2^4}$.\\ Una password è una stringa con meno entropia: se ho una password di N bit, la probabilità di indovinare al primo tentativo è $>>$ di $\frac{1}{2^N}$.\\ Ho 4 problemi maggiori:
\begin{itemize}
\item password overload: gli utenti tendono a riutilizzare le password su più siti
\item restricted charset: 1 byte = 8 bit, quindi 256 possibili combinazioni, ma da tastiera ne ho circa 100.
\item low entropy: la password non è del tutto random, in quanto va comunque memorizzata.
\item predictability: spesso le password sono associate alla vita reale
\end{itemize}
\subsection{Password overload}
Nel 2018, in USA, uno studio ha rivelato che ogni persona ha circa 130 account nel web: il 38\% degli utenti riutilizza la stessa password su più siti. Se scopro una password di un account, posso usarla per accedere su altri siti $\Rightarrow$ cross site break.\\ Il 21\% degli utenti modifica la propria password, ma le modifiche sono predicibili, inoltre il 46.5\% delle password si cracka con 100 tentativi.
\subsection{Restricted charset}
Se ho un segreto di 8 byte, quindi 64 bit, ogni byte ha 256 diverse possibilità, quindi la probabilità di guess al primo tentativo è $\frac{1}{256^8}$. È un numero elevato? \\ Una macchina "ordinaria" può effettuare 66 milioni guess/secondo, quindi il tempo medio per crackare la password è di circa 4431 anni: 1.8x$10^19$ tentativi totali, divido per il numero di guess/secondo e divido per 2 (per fare una media), converto in anni.
Le password però non hanno 256 possibilità per ogni byte, inoltre alcune usano solo lettere lower case, o al più numeri. Anche se vengono introdotti numeri e lettere upper case/simboli, spesso vengono messi in posizioni predicibili (es: all'inizio, alla fine, nel mezzo). \\ Sto considerando un attack brute force offline, in quanto proteggere un web server sarebbe possibile, ade sempio bloccando l'accesso dopo il 3° attempt fallito.
\subsection{Low entropy}
Ci sono dei tool dell'information theory che misurano la randomness. Le password non sono quasi mai random. Come misuro la randomness: Shannon entropy:
Entropia H(X) = $-\sum\limits_{i}p_{i}log_{2}(p_{i})$, considero p $>$ 0, inoltre il segno meno serve perché essendo p $\leq$ 1, il log mi da un valore negativo.\\ La quantità viene misurata in bit. esempio: un coinflip di una moneta equiprobabile ha H(X) = $-2 \cdot (\frac{1}{2} \cdot log_{2}(\frac{1}{2}))$ = 1.\\ Per il dado ho $-6 \cdot (\frac{1}{6} \cdot log_{2}(\frac{1}{6}))$ = 2.58. Per un random byte ho $-256 \cdot (\frac{1}{256} \cdot log_{2}(\frac{1}{256}))$ = $log_{2}(256)$ = 8, ma questo solo se i bit sono davvero random, altrimenti ho un valore minore di 8.\\ L'information value di x$_{i}$ dipende da quanto x$_{i}$ è inatteso: minore è la probabilità di un certo evento e più sono sorpreso, l'information content è quindi = $\frac{1}{p_{i}}$.\\ $-log_{2}(\frac{1}{p_{i}})$ è una traslazione della probabilità in bit, ad esempio $\frac{1}{4}$ diventa 2 bit. L'information content è misurata quindi come $-log_{2}(\frac{1}{p_{i}})$.\\ Definisco l'entropia come l'average dell'information content degli x$_{i}$: H(X) = E[IC(X)] = $\sum\limits_{i}p_{i}IC_{i}$ = $-\sum\limits_{i}p_{i}log_{2}(p_{i})$.\\ Entropia: misura quantitativa per vedere quanto un evento random è predicibile, se pari ad 8 ho un byte perfettamente random, se è 0 è deterministico. Se N = $2^b$ possibili outcome allora b = $log_{2}(N)$, se l'entropia è pari a b, non posso predire. esempio: una moneta truccata con $\frac{1}{4}$ $\frac{3}{4}$ ho entropia pari a 0.81 $<$ 1, quindi è predicibile.\\ Conseguenze: quando trasmetto un bit, trasferisco una quantità minore di informazione, posso comprimere di (1-quantità)\% un file.\\
esempio: genero 3 bit random, ho entropia pari a $\frac{1}{3}$, ma se ci sono dipendenze? Ad esempio se solo il primo è un coinflip e gli altri due sono deterministici, ad esempio prendono il valore del primo ho entropia = 1. Non conta quindi la lunghezza della stringa, bensì la randomness.\\ Nel 1950, Shannon misurò l'entropia di un testo (in inglese), mostrando che il linguaggio naturale è molto predicibile:\\
le lettere che comparivano nel testo non erano equiprobabili, quindi l'information content della singola lettera non è 4.71 (ovvero non ho probabilità di $\frac{1}{26}$ $\Rightarrow$ $-log_{2}(\frac{1}{26}$). Nota la prima,l'entropia della seconda etc... sono in un certo modo predicibili, ogni lettera inglese ha nella migliore condizione 1.3 di information content e 0.6 nella peggiore. Ogni lettera ha un contributo $\simeq$ 2, e quindi generando una password avrò un entropia di circa 2 bit invece di 8.\\ Se ho 10 lettere random:\\
tempo di crack se puramente random = $2^{4,7 \cdot 10}$ = $2^{47}$ attempts, mentre nel caso di password "umana" ho $2^{2 \cdot 10}$ = $2^{20}$ attempts; perdo un fattore $2^27$ $\simeq$ 134 milioni, quindi molto meno robusta.
\subsection{Predicibilità-Dictonary attack}
In realtà, non serve nemmeno fare un brute force attack, ma si possono usare parole note. Faccio un dictionary attack: scelgo una serie di parole comuni in una lingua e faccio try su queste parole.\\ Se riesco a recuperare un set pubblico di password dal web quello brutto e cattivo costruisco il mio dizionario, che può anche essere mirato al singolo individuo (so nomi di familiari, date di nascita, gusti etc...).Gli attacchi funzionano sia online che offline, dove la forza dipende dalla potenza dell'hardware e dalla randomness della password.\\ Alcune statistiche:
\begin{itemize}
\item 25\% delle password è del tipo 123456..., posso pensare anche ad un password sparying: prendo una passowrd e la provo su più account di diverse persone, in verticale (può essere molto efficace).
\item 26\% delle password sono di 6 byte, ne vanno usati almeno 16.
\end{itemize}
\section{Autenticazione password-based vs autenticazione challenge-handshake}
Dopo aver esaminato le password, vorrei un protocollo che mi permetta di usarle per autenticarmi. Ricordo che l'autenticazione è la prova di conoscere un segreto, senza dover per forza rivelarlo. Ho alcune alternative:
\begin{itemize}
\item PAP: mostro la password in chiaro
\item CHAP: alcune informazioni leakate
\item ZPK: nessuna informazione leakate (crypto forte), molto complessi e poco usati nella realtà 
\end{itemize}
\subsection{PAP}
Il protocollo di autenticazione più semplice possibile: mando la password in chiaro, one way authentication. L'utente manda la sua password (insieme allo user id)ad un autenticatore, che fa un check nel DB in cui per vedere se ha una entry user id | password.\\ La password è pre-shared, ma la sto mandando in chiaro e se vengo intercettato è GAME OVER (se il canale permette eavesdropping, se è cablato sono leggermente più sl sicuro).\\ Inoltre non ho nessuna protezione da reply attack: se vengo intercettato, subito dopo l'attaccante può fingersi me, se non enrypto con un algoritmo semantically secure e se non ci sono limiti nel poter ripetere l'autenticazione; inoltre non permetto mutual authentication.\\ Il messaggio PAP è suddiviso in campi specifici a seconda del server a cui mi devo autenticare, se ad esempio ho server PPP: i campi sono espressi in ASCII ed ogni campo ha una semantica, me la studio, prendo il  pacchetto e scopro tutte le info.
\subsection{CHAP}
L'authenticator mi manda una challenge, a cui rispondo con un messaggio contente il mio user id + hash(challenge,password,etc).Proof of knowledge: computazione di un segreto/password, mando una f(password) per dimostrare che la conosco. La funzione deve avere due proprietà:
\begin{itemize}
\item la computazione non deve rivelare il segreto, quindi non devo poter computare $f^{-1}$
\item la funzione f non deve poter essere replicata da un attaccante.
\end{itemize}
L'authenticator mi manda una challenge ogni volta nuova, ovver una nonce. Lo user risponde con userID ed una funzione di challenge, key, etc...(parametri opzionali). La funzione deve rispettare le due proprietà, l'authenticator la ricalcola, dopo aver preso dal db la password corrispondente allo userID ricevuto; la funzione deve quindi essere deterministica.\\ Se la challenge è fresh non sono suscettibile a reply attack, inoltre la password non è inviata in chiaro.\\ La funzione può essere una hash function crittografica.\\ In CHAP è l'autenticatore che controlla tutto il processo: potrebbe accadere che un'attacker potrebbe intercettare la mia sessione kickarmi, sostituendosi a me. Per prevenire ciò, in CHAP è possibile far si che l'authenticator rimandi la challenge periodicamente, per accertare l'autenticità dell'utente. Tutto ciò in PAP non è possibile, ma il grande svantaggio di CHAP è che le password devono essere salvate in chiaro nel db.
\subsection{Hash function}
Funzioni crittografiche di base. Prende qualcosa in input e la riduce in polvere in maniera che sia incomprensibile ed irreversibile. Se ho un messaggio di lunghezza X, Y=H(X) è detto digest ed ha una taglia fissa; H(X) dovrebbe essere abbastanza semplice da poter essere computata su ogni X.\\ Non è sempre detto che le funzioni hash sia crittografiche, alcuni esempi di funzioni non crittografiche:
\begin{itemize}
\item 4 bit parity vector checksum: prendob blocchi da 4 bit e metto un bit di parità sui blocchi. La size del digest (ottenuto giustapponendo i bit di parità) è sempre pari a 4, e la funzione non è invertibile, in quanto l'inversa non è unica
\item modula checksum: spezzo in chunk di interi (valori $\in$ [0,..9]) il mio messaggio, li sommo e ne faccio il mod1000.
\item call center control: devo autenticarmi con username e password, mi richiedono un pin ma non lo mando tutto, bensì solo specifiche cifre.
\end{itemize}
Ogni hash function, anche non crittografica, non è invertibile.\\ Un hash function crittografica prende il testo e lo comprime in un digest di dimensione fissa, ma ha un importante proprietà: anche piccoli cambiamenti producono digest completamente diversi.Deve cercare di approssimare al meglio la generazione di una stringa random.Nel caso di funzioni hash non crypto, un cambiamento minimo è abbastanza prevedibile.\\ Un attaccante non deve in alcun modo ricreare l'hash digest: nel caso di non-crypto hash, cambiando i bit posso ottenere un messaggio diverso che mi fornisce lo stesso digest $\Rightarrow$ collisione. L'attacker non dovrebbe essere in grado di poter ricreare o modificare il messaggio così da ottenere il digest originale. Devono valere 3 proprietà:
\begin{enumerate}
\item Perimage resistance (one-way property): dato y=digest, deve essere computazionalmente difficile trovare X tale che H(X)=Y. Proprietà più forte del non invertibile, la computazione non deve poter essere ricavabile, anche se ho infiniti emssaggi che generano lo stesso digest.\\ Corollario: per essere one-way la lunghezza del digest deve essere grande, non devo potervi fare brute force attacko crypto-analysis.
\item Weak collision resistance: dato X, è computazionalmente difficile trovare un X', che sia diverso da X, e tale per cui H(X) = H(X').esempio: sono un giudice di un tribunale, ho un hard disk su cui ci sono delle prove, lo do ad un esperto per analizzarlo. Come posso essere sicuro che le prove non siano inquinate? Computo l'hash dell'hard disk e lo metto ar pizzo (lo scrivo su un pizzino magari), così che se qualcuno inquina le prove gli do la sedia elettrica, perché vale questa proprietà e non può produrre modifiche tali per cui l'hash è lo stesso.
\item  Strong collision resistance: ci sono funzioni che sono solide per la proprietà 1 ma non per la 2? Sì, ad esempio se considero Y= f(x) = $g^xmodp$: g è dato, p è un numero primo molto grande. Se ad esempio so che 321475 = $3^x$, riesco a ricavare x? Sì, ho che x = log$_{3}$321475, ma se aggiungo il $modp$ non posso più farlo, non è facile computare l'inversa sotto determinate condizioni. Ma non rispetto la proprietà 2: se ho un X, mi basta sommare k$\cdot$(p-1) per trovare lo stesso risultato; la funzione sembra difficile, ma non rispetta le proprietà.\\ Con la strong collision resistance voglio che sia impossibile trovare una qualunque coppia X$_{1}$, X$_{2}$ che collida.
\subsection{Paradosso del compleanno e dimensione del digest}
Voglio vedere come rispettare la strong collision resistance. Considero il birthday paradox: ho k=23 persone in una stanza, voglio associare a ciascuno un hash fatto sul loro giorno+mese di nascita. Probabilità che non ci siano collisioni tra uno dei k e gli altri k-1: $(\frac{364}{365})^{22}$ = 94.1\%. Ma qual'è la probabilità che non ci siano collisioni tra tutti i k: 1 $\cdot$ (1-$\frac{1}{365}$)..... $\cdot$ (1-$\frac{22}{365}$) $\simeq$ 49.3\%. Quindi la probabilità di collidere è il complementare, ovvero 1-0.493 = 0.507 = 50.7\%. esempio: ho n bit di digest, N = $2^n$ diversi risultati. Considero k messaggi:\\ P(no collisioni) = 1-p = $\frac{\frac{N!}{(N-k+1)!}}{N^k}$ = $\frac{N}{N}$ $\cdot$ $\frac{N-1}{N}$ $\cdot$ $\frac{N-2}{N}$ ..... $\cdot$ $\frac{N-k+1}{N}$ $\simeq$ (1 - $\frac{1}{N}$) $\cdot$ (1 - $\frac{2}{N}$) ....... $\cdot$ (1 - $\frac{k-1}{N}$) = $\prod\limits_{i=1}^{k-1}(1 - \frac{i}{N})$.\\ Nelle ipotesi di N grande, 1-i $\simeq$ -i $\Rightarrow$ $\frac{-i}{N}$ $\simeq$ $e^{-\frac{i}{N}}$, quindi ho $\simeq$ $\prod\limits_{i=1}^{k-1}e^{-\frac{i}{N}}$, ma questa è uguale alla somma degli esponenti $\Rightarrow$ $e^{-\sum\limits_{i=1}^{k-1}\frac{i}{N}}$. Ho inoltre che $\sum\limits_{i=1}^{k-1} i$ è la somma di Gauss = $\frac{k \cdot (k-1)}{2}$ e quindi ho $e^{-\frac{k \cdot (k-1)}{2}}$ $\simeq$ $e^{-\frac{k^2}{2N}}$, approssimando k-1 a k. Questa è la probabilità di non avere collisioni: 1-p = $e^{-\frac{k^2}{2N}}$ da cui ln(1-p) = $-\frac{k^2}{2N}$ $\Rightarrow$ k = $\sqrt[2]{-2N \cdot ln(1-p)}$ $\Rightarrow$ k = $\sqrt[2]{2N \cdot ln(\frac{1}{1-p})}$. Quindi all'aumentare del numero di messaggi k, aumenterà la probabilità di collidere. L'obbiettivo è capire quanti messaggi devo raccogliere per avere il 50\% di probabilità di collidere:\\
$\sqrt[2]{N}$ $\cdot$ $\sqrt[2]{ln(\frac{1}{1-\frac{1}{2}})}$ = $\sqrt[2]{N}$ $\cdot$ $\sqrt[2]{2}$ $\sqrt[2]{ln2}$ $\simeq$ 1.177$\sqrt[2]{N}$ $\simeq$ $\sqrt[2]{N}$. Siccome N = $2^n$, avrò k = 1.117 $\cdot$ $2^{\frac{n}{2}}$ $\simeq$ $2^{\frac{n}{2}}$. Se la RAND fosse una perfetta hash function: con 32 bit avrei 4.5 miliardi possibili output, e devo raccoglierne solo 60k per avere una collisione.\\ Per md5, con k = 1.8 $\cdot$ $10^{19}$ = $2^64$ oggi è considerato weak, mentre per SHA256 ho 3.4 $\cdot$ $10^{38}$.
\end{enumerate}
\subsection{PAP vs CHAP}
Posso chiedermi quale fra i due è il più robusto. Bisogna comunque avere chiaro l'adversary model:
\begin{itemize}
\item eavesdropping attack: ascolto chi trasmette
\item rubo i dati dal db
\end{itemize}
In PAP, se qualcuno ascolta il canale è finita, perché la password viene trasmessa in chiaro, quindi c'è la necessità di proteggere il canale di comunicazione (SSL, TLS, EAP/TTLS), ma nel caso in cui ci sia lo steal del DB PAP è molto più robusto, in quanto posso salvare le password non in chiaro. CHAP è invece meglio nel caso del 1° attacco, ma nel secondo no: non posso salvare l'hashing delle password, nel caso di PAP può essere effettuato brute force e la riuscita dipende dall'entropia delle password.\\ Perché in CHAP devo per forza salvare la password in chiaro: in CHAP la challenge è sempre diversa, non posso salvare H(psw, challenge) e se salvo solo H(psw),  non posso ricavare la password perché la funzione non è invertibile.\\ Provo a modificare CHAP: faccio l'hash della password on the fly, ovvero faccio hash(hash(psw),challenge) e mando all'autenticatore, che ora può salvare l'hash della password. Ma in questo modo, se il db viene crackato, non devo nemmeno fare sforzi: userò l'hash della password per rispondere alla challenge e mi autenticherò.\\ In conclusione: 
\begin{itemize}
\item Se l'attacco è sul canale di comunicazione, è meglio usare CHAP
\item Se il canale è robusto ma il BD no, meglio usare PAP.
\end{itemize}
Quando valuto la sicurezza di un sistema devo capire bene cosa l'attaccante può fare e come posso difendermi.\\ Un modo per poter mitigare CHAP è aggiungere del "sale": authenticator mi manda la challenge più del salt, io prendo il salt e lo combino alla password e ne faccio l'hash, che uso per fare hash con la challenge.Cambiando il salt, anche il risultato cambia, quindi posso creare un DB con UID e l'hash di (psw,salt).Rimane comunque il problema in caso di db stealing, ma risolvo buttando via il db e ricostruendolo; sono inoltre soggetto a brute force e dictionary attack. Ho bisogno di un DB aggiuntivo,che proteggo in maniera più forte, in cui salvare le password in chiaro per poterlo ricostruire in caso di steal.
\subsection{Hash Chain}
One time password: voglio una password diversa per ogni tentativo di autenticazione, così da essere al sicuro da reply attack. Sembra una cosa triviale: creo uno userDB con una lista di password random, per ognuna metto un flag che mi indica se è stata già usata o no, quando ne ricevo una la segno.\\ Su na scala reale: se ho molti utenti, il numero di password totali è considerevole, il problema non è tanto nella taglia del DB quanto nel dover cambiare la struttura del DB. L'idea è quindi di generare un numero random/pseudorandom di password da un seed. Uso una hash function crypto, come SHA256, a cui passo il seme e computo il digest. Parto da un seme P[0] e genero P[1] = H(p[0]) e così via, devo quindi salvare solo P[0] per poterle computare tutte. Uso P[0], poi P[1] etc..., ma il modo è errato: se riesco a leggere P[0] poi posso generare tutte le successive, quindi faccio il contrario: mando P[n], poi P[n-1]..., l'attacker non andare al ritroso nel calcolo (sto usando una crypto hash function), non è possibile invertire la funzione.\\ L'authenticator computerà da P[0] a P[n], ma su larga scala questo è oneroso: quello che viene fatto è computare offline, ade sempio durante la registrazione, fino a P[n+1] e salva solo questa. Quando riceverà P[n], farà P[n+1] = H([n]) e lo confronterà con il valore di P[n+1] che ha salvato. Il numero di password è finito, quindi dopo un po' sarà necessario rigenerare la chiave, per creare una nuova hash chain. \\ Posso avere un problema nel momento in cui ricevo l'ok per l'autenticazione, mando il valore successivo e non accade nulla: posso tentare le altre password, se si perde la sincronizzazione tra client e server, so qual'è ultima password correttamente ricevuta lato server (perché ho salvato P[n+1]) e quindi definisco una finestra di tolleranza per cui provo a fare hash per vedere se mi torna il risultato (la finestra va a salire), ovviamente il valore deve essere limitato.\\ Benefit della OTP:
\begin{itemize}
\item Invio in chiaro
\item Rilasso la server security: l'authenticator salva solo la password che si aspetta di computare, quindi in caso di db steal non ho informazioni sulla password esatta.
\item minore complessità del db
\end{itemize}
Problemi:
\begin{itemize}
\item Dimensionare bene n
\item client side è vulnerabile, in caso di key steal è finita.
\end{itemize}
\subsection{2-factor authentication}
Non posso fidarmi della password dell'utente, quindi spesso viene inviato anche un codice (via sms, mail etc...), in modo che l'attacker deve trovare entrambe per poter avere successo. Il codice è un one-time authentication token generato su un device differente e ricevuto su un canale differente.\\ Deve essere human friendly: un codice da 6 a 8 cifre, possibile generarlo con un hash su cui poi viene effettuato un troncamento...\\ Se assumo che sia client che server sono sicuri, non ho bisogno di usare un hash chain: ho due protocolli possibili, HOTP e TOTP
\subsubsection{HOTP-Hash One Time Password}
Ho client e server sicuri, c'è il segreto shared su entrambe, non computo P[n] = H(P[n-1]), bensì P[n] = H(segreto, n); ad esempio P[35] = H(secret, 35) e così via.\\ Anche se ottengo uno dei P[i] non posso ricavare gli altri se la funzione hash è crypto. Inoltre k può essere "infinito", parto da un counter e non devo precomputare nulla. Uso SHA256(k,n) che è un HMAC, e prendo il troncamento del risultato (6-8) digits.
\subsubsection{TOPT-Time-based One time password}
Sistema più sicuro, in cui non devo generare una OTP, am ha come assunzione che il tempo sia sicuro: ho un time sicuro, parto da un timestamp TS iniziale. TOPT = HOTP(k,T), dove T = $\frac{TS}{X}$, dove X è il range nel quale penso non avvenga un reply attack (solitamente 30 secondi). Questo TOTP ha valore per un certo lasso di tempo, computo il valore ad esempio alle 10:46 ed il server riceve alle 10:46, ma se c'è dello sfasamento il valore non torna. Per incrementare la robustezza posso provare ad usare valori precedenti, tolleranza ad esempio di uno slot temporale.\\ Se il tempo non è sicuro, un attacker può cambiare il tempo e riusare una OTP. Ad esempio: server NTP ha precisione di O(10 ms), quindi non è sicuro.
\subsection{Mutual authentication con CHAP}
Assumo che CHAP sia un protocollo sicuro, però è pensato per single authentication. Provo ad adattarlo per mutua autenticazione. Pro tip: non fare mai quello che segue, non si fa. Esce fuori un casino:
\begin{center}
\includegraphics[scale=0.5]{immagini/chap_mutual.png}
\end{center}
Non è una buona idea: uso la stessa chiave per rispondere alla challenge sia dello user che dell'authenticator, ma invece di essere l'utente il primo ad autenticarsi, chiede all'authenticator di farlo (posso farlo se il canale è full duplex). Se però la challenge è la stessa, non è detto che l'authenticator si renda conto che non è cambiata: quando ricevo la risposta posso compiere un reply attack, perché la challenge può essere uguale. Cambio il protocollo in un unico mutuo protocollo: l'authenticator manda il suo nome e la sua challenge, l'utente genera una nuova challenge, manda all'authenticator la nuova challenge e la risposta; ora l'authenticator può verificare che la risposta sia diversa.\\ Reflection attack: mando la challenge C$_{1}$, l'utente mi manda C$_{2}$ + hash per C$_{1}$. Fingo una perdita di connessione, sospendo la sessione e mando come challenge C$_{2}$, l'utente vede C$_{1}$ e C$_{2}$, ma non sa che deve verificare le due sessioni, quindi mi manda la risposta a C$_{2}$ e la nuova challenge C$_{2}$. Ora fingo che la sessione è tornata up e mando la risposta a C$_{2}$.\\ Ulteriore patch: ogni nuova sessione rende invalida la precedente, posso comunque compiere un man in the middle/intertwining attack. L'attaccker prende il messaggio, lo manda all'authenticator e riceve l'autenticazione dal server, quindi fa credere all'utente che è connesso col server.\\ Per fixare: richiedo che venga effettuata una computazione sulla challenge dell'utente e dell'authenticator, ovvero di effettuare crypto binding sulle due challenge. Lo user fa crypto binding su C$_{1}$,C$_{2}$ e si fa mandare dall'authenticator l'hash di C$_{2}$,C$_{3}$, ma così ci sono troppe challenge: l'attaccante invia C$_{1}$, mi faccio mandare l'hash di C$_{1}$,C$_{2}$ posso iniziare una nuova sessione con C$_{2}$.\\ La soluzione prevede che sia l'utente che l'authenticator usino le stesse due challenge, ma scambiando l'ordine con cui viene effettuato l'hashing,ma in questo modo ho progettato un protocollo diverso da CHAP.\\ Avevo due sessioni indipendenti, l'unico modo per renderle dipendenti è usare crypto dependency sulle due challenge.
\section{Nonce}
Una nonce è un valore sempre fresco, ovvero ogni volta diverso.\\ Sono di 3 tipi:
\begin{enumerate}
\item Random challenge: $\sqrt[2]{n}$ in termini di randomness
\item \# seq : più robusto in termini di predicibilità, n.
\item timestamp: è predicibile, ma devo avere garanzia sul tempo (es: GPS e Galileo, GPS può essere spoofato).
\end{enumerate}
La nonce è un superset di possibili challenge, può prevede l'utilizzo di più metodi
\section{Challenge-response authetication in 2G/3G/4G(5G)}
Architettura semplificata di un sistema cellulare:
\begin{center}
\includegraphics[scale=0.4]{immagini/cell_net.png}
\end{center}
La rete cellulare deve garantire almeno queste 3 parti, la serving network offre un servizio di roaming agli altri operatori(non è detto che sia lo stesso operatore dell'utente). l'autenticazione serve perché in questo modo il dispositivo può accedere alla rete e l'operatore sa chi sta accedendo. Usando un protocollo come PAP, la serving netowork vede la mia password e se sono in roaming in paesi molto ad est non so se esistono regole sulla privacy.\\ Non posso fidarmi della serving network, quindi uso un protocollo CHAP-like: la rete è complessa, la parte che gestisce l'autenticazione comunica con la home network.\\ In 3G, il mio device dice alla rete dove sono e chi sono, la serving network contatta la mia home network per ottenere i parametri di configurazione e a questo punto posso autenticarmi usando le credenziali con procedure crypto. In realtà, viene derivata anche la chiave per l'encryption: AKA = Authentication and key agreement, userò anche una chiave successivamente per criptare i messaggi.
\subsubsection{Autenticazione in 2G}
L'autenticazione è unilaterale: la SN manda alla HN l'IMSI che gli comunica il mio device (l'IMSI è il codice della sim) ed una challenge, ovvero chiede alla HN quale risposta deve aspettarsi dall'autenticazione dell'utente. La HN possiede l'id dell'utente e la password, riceve la challenge e ne fa l'hash usando il segreto, producendo l'SRES, fatta da un authenticator trusted: la HN è il ground truth.\\ Inoltre, fornisce la K$_{c}$, ovvero la chiave temporanea che verrà usata dopo l'autenticazione per criptare i messaggi. La SN mi manda la challenge (128 bit random challenge in 2G), io (la mobile station) usa la funzione A$_{3}$ (simile ad un hash function) a cui passa il segreto e la challenge. La risposta è di 32 bit e viene mandata alla SN, che controlla se è uguale alla SRES ottenuta in precedenza dalla HN. Sono protetto, perché la SN non conosce il segreto k$_{i}$ (identity key) dell'utente.C'è anche la fase di key agreement: (k$_{i}$, rand challenge) $\longrightarrow$ k$_{c}$ usata per criptare, schema di symmetric encryption.\\ In wi-fi: dispositivi che si collegano allo stesso AP condividono la stessa chiave di accesso, la protezione è solo dall'esterno, per la protezione interna servono ulteriori meccanismi (TLS,SSL,...) Nel modello appena descritto ogni utente ha una chiave diversa e questa chiave cambia per ogni nuova sessione.\\ La challenge è una nonce, con cui computo k$_{c}$ mediante la funzione A$_{8}$ (anch'essa simile ad un hash function).\\ Se l'utente si collega da più celle, devo ogni volta ripetere il processo descritto sopra, quindi questo è molto lento. L'idea è quella di fornire alla SN un vettore di <challenge, response, k$_{c}$>xN, in modo che la SN abbia N triple e questo porta a diversi vantaggi:
\begin{itemize}
\item viene contattata una sola volta l'HN, quindi pagherò il delay della connessione una volta sola
\item la challenge random è una nonce che deve essere generata propriamente, se la genera la HN e non la SN sono più al sicuro.
\end{itemize}
Quindi lo schema di challenge-response:\\
challenge: RAND | secret: K$_{i}$ | hash: algoritmo A$_{3}$.
Gli algoritmi A$_{3}$ ed A$_{8}$ prendono 128 bit di K$_{i}$ + 128 bit di RAND e restituiscono rispettivamente 32 bit di SRES e 64 di K$_{c}$ (anche detto il segreto di Pulcinella). $2^{64}$ non è computabile, ma $2^{54}$ sì: la chiave K$_{c}$ era di 54 bit, estesi a 64 con 10 zeri alla fine.
\subsubsection{Scelta degli algoritmi}
A$_{3}$ ed A$_{8}$ girano nel chip della sim. Ma io non ho accesso al chip della sim, quindi non conosco l'implementazione di A$_{3}$, ma non ne ho bisogno. Nemmeno la SN deve conoscerla, il risultato sta già nella tripla, è proprio la response, che è l'SRES, quindi ogni operatore può scegliere gli algoritmi che preferisce. Gli operatori scelsero di usare un algoritmo noto, COMP128 che non era open source, ma veniva tenuto nascosto $\Rightarrow$ security by obscurity. CI fu un leak del codice, e questo venne analizzato e violato da crypto guys molt forti in O(min), rendendo vulnerabili milioni di sim.\\ Morale:
\begin{itemize}
\item Security by obscurity non funziona, perché è difficile che se scoprono una vulnerabilità non la dicano.
\item Algoritmo pubblico viene validato dai crypto shark che cercano di romperlo per il clout.
\item Preferisci sempre l'open source al codice chiuso per la sicurezza
\end{itemize}
\subsection{Autenticazione in 3G/4G}
Il problema del 2G sta nel fatto che l'algoritmo per computare K$_{c}$ era vulnerabile, ma non c'era nemmeno mutual authentication: suscettibile ad over the air attack, ovvero una finta base station a cui l'utente si collega. La base station non prova mai la sua autenticità, e non voglio questo. Uso un algoritmo open source per la mutua autenticazione:
la mobile station comunica il suo IMSI alla SN, che lo manda alla HN e riceve una 5-pla <rand, XRES, C$_{k}$, IK, AUTN>xN.\\ L'IK è l'integrity key, usata per garantire l'integrità del messaggio. Questo perché l'encryption non la garantisce, quindi serve una chiave diversa dalla K$_{c}$ per garantirla.L'AUTN serve invece per provare l'autenticità della rete all'utente, è il Network Authentication Token.\\ La SN mi manda l'AUTN e la rand, provandomi di essere trusted, ma l'AUTN è stato prodotto dalla HN, quindi voglio che sia il device a produrre la challenge che la SN dovrà risolvere. In questo caso non è così, dovrei avere due nonces, uno dall'MS alla SN ed uno dalla SN alla HN.\\ Funzioni usate:\\
f$_{2}$(K, RAND) = 32 bit di RES\\
f$_{3}$(A$_{8}$ equivalent)(K, RAND) = 128 bit di C$_{k}$\\
f$_{4}$(K, RAND) = 128 bit di IK\\
Tutte dipendono solo dal segreto dell'utente e dalla random nonce, le implementazioni sono note.\\ Sarebbe possibile autenticarsi con un solo messaggi, usando il timestamp:\\
se la mobile station e la SN usano ad esempio GPS, sotto l'assunzione che il tempo sia sicuro, conoscono perfettamente la nonce usando TS.\\ Farò H(TS,K), non posso avere reply attack etc... e con questa forma di nonce evito l'uso della challenge.
\\ La mutual authentication in 3G+ (simile anche in 4/5G) prevede che la MS invii una nonce, invece di usare una quantità random, usa un \#seq number: in questo modo posso sapere quante volte ho fatto un accesso e qualcuno nella rete mi dice che mi sto autenticando per la \#seq + 1 volta. Se mi arriva un messaggio con un \#seq vecchio, scopro che è un reply attack. Se il vece il \#seq è più grande anche solo di 1, va bene (definisco anche in questo caso una tollerance window): i numeri di sequenza della MS e della HN devono essere sincronizzati, perché la SN si autentica alla HN per ottenere il vettore di credenziali.Quindi, quando mi autentico, uso il \#seq come challenge implicita, risparmiando un messaggio: il messaggio che mi fornisce la SN è un'operazione della nonce + k, usando le credenziali fornite dalla HN; in questo modo so che la SN ha le mie credenziali. È un 2-way exchange con 2 messaggi, il problema è che la MS e la HN devono essere sempre approssimativamente sincronizzate; se si perde la sincronia, servono dei meccanismo per ripristinarla.\\ Format dell'AUTN:\\
N° sequenza a 48 bit | AMF: 16 bit di auth and key management | 64 bit di MAC-A, derivato come segue: MAC-A = f$_{1}$(k, SQN, AMF, RAND), la coppia SQN + RAND corrisponde ad un crypto binding, K ed SQN sono la proof of knowledge di k, l'AMF sono informazioni aggiuntive.\\ Una volta connesso alla service network, questa mi manda un TMSI, ovvero un identificatore temporaneo allocato dinamicamente quando mi collego; nelle prossime autenticazioni userò questo TMSI (GUTI in 4G). Il TMSI è meglio per la privacy, in quanto se mi collego usando sempre l'IMSI, posso essere tracciato, invece qui uso una quantità che via via cambia.\\ L'unica vulnerabilità è che la prima volta l'IMSI viene mandato in chiaro, bisogna cercare di usarlo il meno possibile.\\ Mi autentico ed ogni volta che mi ricollego cambia il TMSI, occorre fare molto lavoro aggiuntivo per evidare che i TMSI siano legati fra loro. Devo inoltre proteggere il sequence number SQN: potrei non trasmetterli ed usarli davvero come informazioni implicite, oppure produrre un encryption con la chiave, ma prima del collegamento non la ho: se però sono autentico ed anche la SN lo è, allora vuol dire che entambi conosciamo k, quindi possiamo derivare qualcosa da k. Faccio l'encryption del SQN con un pattern AK apparentemente random: rendo AK computabile per entrambe gli end, quindi poi la base station potrà risolvere:
\begin{itemize}
\item leggi random
\item computa f$_{5}$(k, random) = AK di 48 bit
\item de-anonimizza \#seq : \#seq $\oplus$ AK $\oplus$ AK = \#seq
\item  leggi il resto del pacchetto
\item computa f$_{4}$(\#seq , k, rand, AMF) = MAC-A
\item controlla il MAC-A 
\end{itemize}
\section{Pro-tip: come generare password a partire da un segreto master}
Ho il seguente problema: devo generare chiavi infinite per infiniti utenti: posso usare un PRNG e mettere i record userID | password in un database e proteggere il DB. Pro tip: uso un master secret S, che tengo al sicuro, e quando devo generare una nuova chiave per l'utente uso un identificativo univoco per l'utente (es: il codice fiscale) e faccio hash(S, UID).
\section{Message authentication-Integrity}
In 3G e oltre ho l'IK per l'integrità del messaggio, faccio quindi messsage authentication. Ricordo che la confidenzialità è diversa dall'integrità: con la prima,voglio nascondere il contenuto del messaggio mentre con la seconda voglio che il messaggio non sia modificato durante la trasmissione, solo la sorgente legittima dovrebbe poterlo forgiare.\\ Ho bisogno di un algoritmo che garantisca l'integrità.
\subsection{Message Authentication con symmetric key}
Il sender ed il receiver che hanno una stessa chiave k, ad ogni messaggio aggiungo un TAG = gen\_tag(k, message). Il messaggio ha una size arbitraria, ma il tag deve avere size fissa, quindi userò qualcosa di simile ad una funzione hash. Il receiver riceverà il pacchetto e ricomputerà il tag, confrontandolo con il tag ricevuto. \\ esempio: message authentication code (MAC) è più debole della firma digitale\\
La firma digitale non può essere contraffatta, nessuno può modificare un messaggio firmato da me. Nel caso del tag sender e receiver possono modificare il messaggio, chiunque possiede k può farlo. La digital signature ha la non repudiation property o source authentication. Ad esempio, in una chat multicast si usa la stessa IK, quindi chiunque può produrre un messaggio spaccandosi per me, con la firma digitale questo non può accadere.
\subsection{Message Authentication con hash functions}
Ho mai detto che una hash function può essere usata per msg auth?\\
Nuovo problema: come usare hash function per msg auth e ci saranno problemi (perché non è quello il purpose per cui è pensata).\\
Encrytpion non garantisce integrità a meno che si usi un authenticated enrcyption $\Rightarrow$ AEAD algorithms, Authenticated Encryption Associeted data ovvero un algortimo che fa sia encryption e authentication.\\ In TLS 1.3 (la nuova) hanno proibito di usare algoritmi che non abbiamo authentication, quindi sono AEAD.\\
AES-128 o AES-256 è enrcyption only, AES-GSM o AES-CCM sono auth enrcyption.\\
\subsection{Message authentication with simmectric key}
Prendi msg m, computa con una chiave k nota ad entrambi gli end(nota $\Rightarrow $che è pre-shared)
C'è una funzione che è usata per generare il tag: riceve una size arbitraria e produce un tag di size fissa e possibilmente piccola (non troppo, per birthday paradox).
Trasmetto msg + il tag, message authentication code aggiunge bytes al msg, c'è dell'overhead in quanto non deve aver infromazione(il msg in se è al massimo livello di entropia).
Recevier verifica il tag usando la stessa funzione, nota e condivisa, generando il nuovo tag dal msg + chiave k e lo confronta con quello ricevuto.\\
\subsection{Definizione di sicurezza per Message Authentication Code}
IND-CPA model definiva la confidenzialità, posso trovarne uno analogo per msg auth?\\
Sicurezza in integrity vuol dire che l'atk non può essere in grado di creare un nuovo msg o poter modificarne uno; anche se il msg modificato perde di senso è considerata una violazione.\\
Formalmente, faccio un "gioco" contro l'attaccante:
\begin{itemize} 
\item attacker model può essere Known Message Attack o Chosen Message Attack, ovvero attacker può chiedere qualsiasi coppia (msg,tag) precedente
\item può essere adattivo ovvero che il msg è scelto dopo una analisi della situazione.
\end{itemize}
Ora, se l'attacker scegli uno nuovo messaggio m, diverso da quelli del passato per cui ha i tag, non deve poter forgiare il nuovo tag per il msg m.\\
Formalmente, la probabilità di forgiare una coppia valida deve essere un $\epsilon$(prob dell'ordine di $2^{-100}$):
\begin{itemize} 
\item Devo escludere che il tag sia di 1 byte
\item Non può tirare a caso il tag del msg con scelta puramente random.
Se fosse di 1 byte $\Rightarrow$ avrei $\frac{1}{256}$, che non va bene, il minimo è almeno 96 bit di tag (meglio 256).
\end{itemize}
Differenza cruciale nella scurezza: IND-CPA l'attacker poteva scegliere se il msg era A o B e aveva esattamente $\frac{1}{2}$ possibilità.\\
Message integrity protegge dal man in the middle? Sì, genero il msg m, produco il tag=F(K,m). L'atk intercetta il mesaggio e vuole cambiarlo: se F è cryptographically strong:\\
\begin{itemize}
\item K non può essere computata dal msg e dal tag.
\item Non posso cambiare il tag in un nuovo tag senza conoscere k, non posso computare tag*=G(K,m*)
\item Non posso cambiare m in m' così che F(K,m)=G(K,m')$\Rightarrow$ anticollision property.
\end{itemize}
Se lo schema è sicuro, allora potrò sempre intercettare un mitm atk.Mitm ha due aspetti:
\begin{itemize}
\item networking class: triviale farlo,ARP poisoning, DNS spoofing.\\
\item Il msg è efficace se posso modificare il msg, non solo cambiare il flow dei msg.
\end{itemize}
Un buon algoritmo deve anche proteggere dalla creazione di un nuovo msg: message spoofing$\Rightarrow$ creo un nuovo messaggio in cui metto un ip fake facendoti credere che è quello con cui vuoi comunicare.\\
Posso risolverlo con un auth mechanism:\\
Se ogni msg è autenticato: DNS è autenticato in plaintext, come faccio a sapere che è proprio, es. Google.com?\\
Devo aggiungere qualcosa che mi garantisce che sia Google ad esempio con un tag.(la versione di DNSSec dovrebbe proteggere da questo, ma questo aggiunge complessità alla rete quindi si continua ad usare DNS.)Posso spoofare msg, ma devo conoscere il tag$\Rightarrow$se algoritmo è buono probabilità è un $\epsilon$.\\
Questo schema NON protegge da un reply attack:\\
voglio mandare due messaggi, es due transazioni. Produco due msg identici, ma la F si applica alla chiave$\Rightarrow$la F deve essere deterministica (va ricomputata all'altro end)e quindi i tag saranno gli stessi,MAC non è abbastanza.Ma se i messaggi hanno un contenuto diverso: timestamp, num. seq etc.. potrei dire che non ci sono problemi.Ma non è così: l'applicazione dovrebbe essere disegnata senza avere in mente problemi di sicurezza.Il protocollo deve essere sicuro, non mi deve importare dell'applicazione.\\
Prevengo reply atk: uso le nonces, devo garantire a livello di protocollo che tutti i messaggi siano diversi, aggiungo una nonce ai msg. Computo il tag sul msg+nonce, posso mandare la nonce in chiaro.\\
\begin{itemize}
\item Se uso seq num: come gestisco i reboot?Devo prestare attenzione.
Parto da 0 e vado avanti, però perdo alcuni n° sequenza, come faccio a dire che i pacchetti ricevuti con alcuni buchi in mezzo sono ok? Devo tenere in mente l'utlimo correttamente ricevuto per discriminare reply atk.
\item Random number, se truly random sono meglio.Non ho probelma del reboot, ma come controllo se pkt è nuovo? Ho un certo n° bit,quindi dovrei tenere tutt la lista de msg precedentemente ricevuti, costo di memoria  e di computazione per il controllo.
\item Timestamp migliore possibile, ma il tempo deve essere garantito o ho problemi.
\end{itemize}
Settare una nonce sembra facile ma non lo è, la maggior parte dei probelmi implementativi è qui.\\
1° ingrediente:\\
Hash functions: molto veloci, sono anticollsione se cryptographic. Buoni prodotti:
\begin{itemize}
\item SHA-2 family(SHA256, SHA224,SHA384$\Rightarrow$SHA512 troncato, SHA512).
Nel passsato SHA1 e MD5, MD5 la più comune e famosa funzione hash,oggi tutte e due rotte.
\item Next: SHA-3 family, sempre gli stessi digest ma con approcci differenti.
\end{itemize}
es: in TLS e Ipsec, SSH non troppo serio si usa SHA256, sha256sum fa hashing di file su Linux.\\
2° ingrediente:\\
Includo il segreto nell'hashing del messaggio messaggio.
Facile? Ma dove metto l'auth key nel msg?Lo metto dopo il messaggio: H(M$||$K), o faccio il contrario?\\
O in altri modi? Ad esempio metterlo sia all'inizio che alla fine etc..Perché me ne preoccupo?\\
Una funzione hash teorica è una black box, c'è anche definizione per la perfect hash function:\\
Random Oracle: black box, che preso input X, H(X) = valore truly random, ma che si ripete se X è lo stesso. Ma le due cose non possono coesistere, H(X) deve essere computabile. Nella teoria questo è il modello ideale (come per one time pad) che vorrei avere, ma non posso implementarlo.\\
Devo vedere nel box:tutte le hash functions (tranne SHA-3, oggi non usate) sono costruite con la costruzione iterative Merkle-Damgard:
è difficile trovare f tale che: f(any size)$\longmapsto$ fixed size. Ma è possibile trovare f t.c:\\
f(fixed size)$\longmapsto$ samller fixed size otuput. Compression function, che possono essere molto buone.\\
es: sha256\\
prendo msg di k bit, paddo il messaggio in modo che il risultato(compreso i 64bit di lunghezza del messaggio) sia multiplo di 512 bit: se ad esempio la size del mio file è 1025 bit, metto un bit ad 1 seguito da vari zeri, alla fine del msg mette la size del msg come lunghezza modulo $2^{64}$, sono 64 bit (faccio il modulo nel caso in cui lunghezza sia maggiore di $2^{64}$, così che sia di size fissa).
Ora taglio il msg in chunks di 512 bit: parto con un initialization vector(non crypto) che è noto e fisso, deve poter essere ripetuto. SHA256 prende IV 256bit,diviso in 8 gruppi da 32, è una costante.L'IV fa sì che la funzione di compressione prenda 512(il chunk) + 256(l'IV) = 768 bit di input.Questo perché SHA256 usa aritmetica $\bmod$32 o 64 a seconda dell'architettura.La compression function comprime i 768 bit in 256 bit che è l'hash summary del chunk 1.\\
Ma ora, se uso questi 256 bit come input per un secondo blocco di compressione, che comprime il chunks 2? SHA256 reitera la stessa funzione di compressione.
La F è il cuore dell'hash function, theorem di Merkle-Damgard dimostra che se F è resistente, ovvero soddisfa le 3 proprietà di una funzione hash$\Rightarrow$l'intera costruzione è sicura.(la F non deve essere lineare)\\La chiave è trovare una buona compression function, questa prende un input fisso e ridà un output fisso, a questo punto posso usarla iterativamente; l'ultima iterazione mi darà i 256 bit finali.\\
In che posizione metto il segreto nell'argomento dell'hash fucntion? Prima del messaggio, o dopo, o in altri modi?
La posizione del segreto conta ed è importantissima:\\
es: msg di 1GB, segreto 128bit, poi ho pad+length.Messaggio è noto, vedo il tag = hash(msg,k), vado da 0 a $2^{128}$ e faccio H(msg,k$_{x}$)=?tag. Brute force atk devo computare fino al massimo $2^{128}$ hash functions.\\
SHA256 è white box, so che è costruita iterativamente, il msg è sempre lo stesso: computo i primi blocchi che contengono il messaggio e prenderò l'output precomputato (i 256 bit risultanti), ed ora dovrò computare solo l'ultimo pezzo a partire dal precomputato.Non quindi computare N$\cdot$ $2^{128}$ blocchi, bensì $2^{128}$ $\Rightarrow$ riduco la complessità d un fattore N.\\Se metto il secret all'inizio, posso rompere la forgiability?Posso forgaire un tag valido per un m\textsuperscript{'} scelto da me, partendo da M,tag=H(s,m). Sì è possibile:\\
triviale forgiare un messaggio autenticato valido
m' != m.
Estendo msg, che può anche essere insensato, con una parte di plaintext.\\
Non posso modificare il msg originale ma non è un problema, inoltre lo faccio senza conoscere il segreto: es. aggiungo una transazione alla fine del messaggio.Aggiungo extra chunks, partendo dal MAC code di prima e genero un MAC extended valido.\\
Questo è un problema $\Rightarrow$ ho una funzione forte, ma la costruzione rompe tutto (errore tipico della crypto), quindi non si usa mai una funzione non pensata per quel purpose, anche se i purpose sono simili.\\
La posizione del segreto CONTA TANTISSIMO.\\
Come fixare il problema:\\
Hash Based Message Authentication Code (HMAC), che è stata dimostrata essere sicura come l'hash sottostante.\\
Ho imparato che una secure hash non basta, quindi HMAC aggiunge un modo sicuro di aggiungere segreto nell'hash, non patcho l' hash in se quindi non dipende da come è fatta l'hash.\\
1996, paper di Bellare, Canetti e Krawczyk con due versioni: crypto e IETR RFC 2104.\\
Pluggable hash e usando l'HMAC non aumenti il costo computazionale di molto:\\
HMAC$_{k}$(M)=H(K\textsuperscript{+}$\oplus$opad |H(K\textsuperscript{+}$\oplus$ipad|M)\\
Il primo pezzo contiene la chiave, i secondo il messaggio. Sembra che sto facendo come prima, ma in realtà sto usando hash del messaggio tra message e secret alla fine. Quindi faccio hash della chiave seguita da hash di message e chiave,come fare 2 volte hash del msg.\\
Se il segreto K è $<$ della lunghezza di un blocco fai si che sia di pari lunghezza, paddo con zeri, ottengo così K\textsuperscript{+}.Questo è il primo chunk di SHA256.\\Per la sicurezza della costruzione, i due segreti che uso negli hash devono essere diversi: miglior costruzione è la nested MAC construction : H(secret$_{1}$ !! H(secret$_{2}$ !! msg)). Ma chiedere di usare due segreti sarebbe stato un disatro, quindi per praticità non era conveniente lasciare all'implementatore la scelta dei due segreti.\\Soluzione è che produco due segreti dviersi a partire dallo stesso: in entrambi i due risultati flippo bit diversi riseptto all'originale, sembrano quindi due segreti indipendenti(ma non lo sono) ed hanno una distanza larga in termini di bit.\\
es : k = 01010101, inner: 01010101$\oplus$01011100=K$_{o}$, outer: 01010101$\oplus$00110110=K$_{i}$ (entrambe le sequenze ripetute come serve).\\
Parto dal msg, aggiungo all'inizio (prefix) K$_{i}$, runno hash function: parto da IV e lo unisco a K$_{i}$ ed ottengo un secret IV.Hash sugli altri chunks, ed ottengo l'inner hash: ho un classico MAC secret prefix, devo mettergli una pezza: prendo l'oueter key K$_{o}$ e faccio hash del singolo blocco (inner hash + pad).\\Ottengo quindi HMAC, che è dimostrato essere una costruzione sicura.\\
storiella: 2005 md5 broken, tutti gli HMAC tags usavano md5. Thm ti dice che la costruzione è sicura quanto l'hash sottostante: se l'hash è unsecure $\Rightarrow$dovrebbe rompersi anche il meccanismo di HMAC. 2006: non era ancora stato trovato un atck pratico ad HMAC di md5.\\
Assunzioni: modello math dell'hash function:
\begin{itemize}
\item pseudorandom output
\item anticollision property.
\end{itemize}
Entrando nei dettagli, Bellare si rende conto che non usa mai la proprietà 2 e capisce che HMAC è più sicuro dell'hash fuction, finché la properietà 1 non è violata.\\
Paper del 2006 su collision resistance NON necessaria.\\
Messaggi importanti:\\
\begin{itemize}
\item Confidentiality != integrity
\item Message authentication with symmetric key
\item Reply atck: MAC non è abbastanza, servono nonces e vanno gestite bene.
\item Crypto hash functions
\item Come includere key nell'hash fuction? Non è triviale, usa HMAC.
\end{itemize}
\section{Gestione dell'accesso remoto: RADIUS}
Tool usato nel backend, Remote Authentication Dial In User Service, obsoleto:\\
oggi migliori protocolli(DIAMETER) ma ci sono un sacco di problemi quindi è utile studiarlo.\\
Posso accedere alla rete usando diverse tecnologie, tutte eterogenee fra loro e largamente distribuite. Gestire la rete con tutte queste tecnologie ed access point: uso server centralizzato, RADIUS server che è incaricato di gestire username e password dell'utente, così da evitare la distribuzione all'interno della rete.\\Anche una questione di sicurezza:(di solito in AP: Linux machine con db interni), non lascio username e psw distribuite in giro per la rete.\\Devo cambiare l'authentication model: faccio auth con local technology, RADIUS client che counica con l'utene e col server contatta quest'ultimo ed il server ,manda RADIUS response con un si o no a seconda se l'utente può accdere o meno$\Rightarrow$parte più importante.Il client dice quindi all'utente se può entrare o no(l'utente non sa che sta usando RADIUS).\\
\subsection{RADIUS: AAA protocol}
3 servizi di solito eseguiti insieme:
\begin{itemize}
\item Authentication
\item Authorization: da non confondere con Authentication, qui voglio sapere che l'utente ha il permesso di usare il servizio (perché ha pagato o per altri motivi).
Posso avere 
\begin{itemize}
\item authentication senza authorization
\item authorization without authentication ed avrei un servizio privacy preserving.\\Letteratura scientifica è ricca di tecniche per farlo, ma nel mondo pratico non molto usato.
\item l'intersezione fra i due.
\end{itemize}
Serve per management
\item Accounting: transmitted bytes (quanti GB sto consumando), billing, minuti di telefonate spese etc..\\Segno cosa stai facendo in termini di una risorsa che stai usando.
\end{itemize}
\subsubsection{RADIUS è client-server protocol}
Richiesta parte dal client, non confondere il RADIUS client con l'end user, ovvero il NAS: ho end user - NAS- RADIUS client- Server.\\Basato su UDP/IP porta 1812, client port è ephemeral. Sistema centralizzato, logicamente centralizzato: in teoria ho un singolo server ma in pratica è ridondato (sennò è single point of failure)\\In RADIUS si può usare roaming: se cambio città rispetto a dove sta il server, es. della mia università, dovrei cambiare account, ma quello che accade è che la mia richiesta viene presa dal RADIUS server della città e la inoltra al RADIUS server della mia univeristà, agendo da proxy server.\\Architettura complessa, diversi blocchi:
\begin{itemize}
\item Server application
\item User db: per ogni username ho almeno authentication info, authentication method e authorization attributes
\item Client db: clients che possono comunicare col server.
\item  Accounting db: se RADIUS usato per accounting, deve essere aggiornato in real time, per questo separato dal db utente.Non necessario se si fa solo authentication.
\end{itemize}
\subsubsection{RADIUS security features}
Due feature, 1° è
per packet authenticated reply: NAS non ha le mie credenziali, le manda al server, atck interecetta il messaggio e risponde con un "sì", il NAS ora vede che l'utente è autenticato.Non devo pter spoofare il msg$\Rightarrow$deve essere autenticato, ed è quello che è stato fatto: si usa shared secret, approccio CHAP-like,ma:
\begin{itemize}
\item solo la reply è autenticata
\item l'autenticazione è hash based e non HMAC-based
\item funzione hash specifica MD5, quando uso una hash function deve essere future-proof, se metto uno specifico crypto algo in un protocollo è male: qualcuno prima o poi lo romperà. Non è semplice andare poi a modificarlo. Il protocollo è una cosa, l'algoritmo di encryption deve essere messo a parte, così da cambiarlo in caso venga violato.
\item Secret non truly random, ma low-entropy shared key
\end{itemize}
2° servizio: user password enrcyptata: se uso PAP, ho la psw in chiaro. Standardizzazione di un meccanismo. Problemi:
\begin{itemize}
\item Custom mechanism, non inventare algoritmi per quanto possibile, ma usane uno già esistente. (Non era rotto, però devo considerarlo come possibile vulnerabilità).
\item Shared secret key usata anche per l'authentication $\Rightarrow$NUN SE FA, anche se non è exploitabile è errato, perché se rompi la chiave rompi più di un servizio.
\end{itemize}
\subsubsection{RADIUS authenticated reply concept}
End user credentials $\Longrightarrow$ manda le credenziali al NAS, RADIUS client e server hanno uno shared secret che è $\neq$ dalle credenziali del utente. NAS parsa le informazioni e le traduce nel RADIUS language, include le credenziali in un pacchetto RADIUS che è un pacchetto UDP/IP che ha:
\begin{itemize}
\item ID field: mi permette di matchare una richiesta con la risposta.
\item Authentication field: nonce di forma strana, è una nonce che mando al server così che il server possa creare un reply message (sì, no go-on se servono più informazioni) e possa autenticare il pacchetto, ovvero il pacchetto deve avere un authentication tag. In message authentication includevo il TAG (che era HMAC di K + content), qui ho una cosa analoga: ho la risposta, il tag si costruisce combinando l'ID, il valore random usato come nonce ed il segreto pre-shared.MAC=H(ID,nonce,secret).\\ Il reply può anche avere authorization, esempio poter permettere accesso per un tempo limitato.
\end{itemize}
NAS si tiene in un local db l'associazione ID-nonce(authentication). Faccio un check e se mi torna $\Rightarrow$ sono sicuro che il messaggio mi è arrivato dal server e so che non può essere replicato perché l'auth è fresh per ogni nuovo handshake.Ora NAS passa l'informazione all'end user. È una sorta di challenge-response:
\begin{itemize}
\item la challenge è il request authenticator
\item la risposta include anche,una volta validata, il messaggio di risposta.
\end{itemize}
Formato del pacchetto:\\
IP header | UDP header | RADIUS packet: 
\begin{itemize} 
\item byte di codice:
\begin{itemize}
\item 1) sì
\item 2) no
\item . . .
\item 3)access challenge: sta per go-on, non inteso come la classica challenge.
\end{itemize}
\item 1 byte di identifier
\item 2 byte di length per il pacchetto
\item 16 byte di authenticator che deve essere non replyable $\Rightarrow$ unique. Sono 128 bit $\Rightarrow$ $2^128$ possibili authenticator, se fosse realmente truly random, avrei avuto probabilità di collidere proporzionale al birthday paradox (ordine $2^64$). 
\item Attributi sono triplette di (type,length,value), ogni tipo corrisponde ad un determinato tipo (username, password, framed-MTU, Callback-number)
\end{itemize}
Authenticator field: la parte più importante per la sicurezza.Dovrebbe essere unico ed unpredictable per evitare reply attack. Ha due scopi: nell'access request server per authentication mechanism, nella response è sempre di 16 byte ma viene usato per il TAG. TAG è MD5(Code|ID|Length|RequestAuthenticator|Attributes|Secret): qui code è codice di risposta, length è la lunghezza del pacchetto di risposta, attributes sono le triplette. Request Authentication si ottiene dall'access request.\\ Access-request di solito contiene 2 classi di informazioni, uno dell'utente ed uno dell'access service device:
\begin{itemize}
\item Username: NAS ha le credenziali, deve mandarle al server
\item Password dell'utente
\item Identificatore del RADIUS client, NAS-IP o NAS-identifier
\item Identificatore della porta a cui l'utente sta accedendo, la NAS-port (se il NAS ha una porta)
\end{itemize}
Access-reject: o ho fallito l'autenticazione oppure non ho l'autorizzazione (esempio: non ho pagato)\\
Access challenge è un go-on message: usato quando server vuole che venga fatto altro: ci sono altri protocolli di autenticazione (esempio: EAP-TLS, EAP-TTLS) in cui devo fare più operazioni, che richiedono più messaggi
\subsubsection{PPP CHAP support with RADIUS}
In una situazione normale di challenge handshake ho user, server: server mi da challenge,rispondo e lui mi dice si o no.\\ Nel caso di user | NAS | server:\\
potrei generare un processo simile, ma se faccio questo devo anche mandare il segnale fisico per far capire che l'utente è attivo: overhead grande, devo "svegliare" l'utente, il NAS deve chiedere la challenge al server e così via.\\ L'utente si sveglia, il NAS genera la quantità random (mi dovrei fidare dell'access point): utente risponde con hash della password e della challenge usando CHAP. Il NAS crea Access-request RADIUS con Username|Risposta della challenge| Chalenge|Servizio....\\ Or il server può verificare se il client è autentico e decidere se dargli accesso o no, manda RADIUS Access accept. Nel caso di protocollo CHAP non uso access-challenge message, uso solo Access-request.\\ Vulnerabilità: messaggio del NAS non è autenticato, l'Access Accept non contiene la tripletta di username o psw, è anche vero che la challenge cambia sempre.NAS non può verificare che la challenge era quella vera. Attacco:\\ prendo il NAS, mando una challenge "1234" e user manda reply"$\alpha\beta\gamma$" NAS manda il pacchetto al server ed ottiene Access Accept.\\L'attacker si finge me: prende il pacchetto che ha generato fingendosi me e sostituisce ai campi dell'auth che il NAS gli ha mandato e la sua risposta alla challenge (che è random,tanto non è importante che sia corretta), a quel punto lo invia al server e non è detto che il server faccia un check per vedere se la challenge che il NAS mi ha dato è fresh o no. Attacco al payload del messaggio: rispondo con una coppia di valori precedenti validi. \\ Dal 1998 anche le richieste diventano autenticate, ma non era una cosa necessaria.\\ Problema: posso fixarlo? Potrei pensare di autenticare reply e request, ad esempio fare HASH(request, reply).
\subsubsection{Password encryption}
Se user manda username e psw con PAP: NAS dovrebbe mandare nel RADIUS packet, ma sono in chiaro. La rete in generale, tra il NAS ed il server RADIUS non può essere trustata $\Rightarrow$ tecnica per criptare la password: predo la psw nativa, la paddo per riempire un blocco da 16 byte, faccio MD5(secret|RequestAuth), risultato sembra una string pseudoranom, quindi uso una tecnica simile allo stream cipher: il keystream non è prodotto da uno PNRG, ma da un hash function. Psw è messa in XOR con il keystream ottenuto dall'MD5(secret|RequestAuth). Se la psw è più di 16 caratteri: posso dividerla in due blocchi e paddarla con lo stesso valore, ma il segreto è lo stesso e c'è una sola nonce $\Rightarrow$ padderei due volte con lo stesso keystream. Computo un keystream differente, usando il cipertext precedente e faccio XOR con i due blocchi in cui divido la password.
\subsection{RADIUS Security Weakness}
Vulnerabile al message sniffing e modification. Access request non è autenticato, il testo è mandato in chiaro quindi ho problemi di privacy.\\ Soluzione non c'è, devi coprire con un altro protocollo (ad esempio TLS), per l'autenticazione usato EAP (Exstensible Authentication Protocol): protocollo che permette di scambiare messaggi di autenticazione, difatti nella specifica si trova EAP-TLS, EAP-AKA, ovvero usi un protocollo di autenticazione con dentro un AEP packet exchange.\\ Message authenticator: ho un pacchetto di richiesta: contiene code|ID|Length|RandomAuth|triple(T,L,V) devo aggiungere un TAG, l'idea è di creare una nuova tripla T,L,V in cui il tipo fosse sepcifico per l'autenticazione. Il valore ora è computato con HMAC-MD5, type è 80 e lunghezza 18.\\ Reply atck: evito reply attack al pacchetto RADIUS di base, ma posso fare reply di una richiesta. Il pacchetto contiene una nonce e l'auth TAG, ma questo è un pacchetto valido, quindi posso replicarlo. Per evitare reply attack di request message, il server deve verificare che la nonce sia fresh. Può o non essere un problema: separa la practical explanation dalla vulnerabilità, deciderà chi implementa se questo è un problema o no.
\subsubsection{Dictionary attack to shared secret}
Problema grande di RADIUS, cos'è lo shared secret? Segreto che sceglie il network manager, problema è che è difficile che venga inserita una stringa truly random, ma una stringa a low entropy, ricorda inoltre restricted charset. Spesso un singolo segreto è usato per tutta la rete esempio: Fonera, aggregazione di AP a cui si ci può connettere in roaming. Stesso segreto per 100k+ device ed era triviale (tipo Salute! in spagnolo).\\ Quindi, usare uno shared secret per ogni client (metodo del segreto unico, che conosco solo io e ne faccio HMAC con un identificatore univoco dell'AP).\\ Possibile fare dictonary attack offline:\\ intercetto una coppia (request,response), ho tutte le info per fare brute force o dictionary atck e posso fare precomputation perchè il segreto è alla fine nell'MD5 del response packet.\\ Se richiesta e risposta su due canali diversi, e posso accedere ad esempio solo la request: non serve la coppia. Siccome il segreto è lo stesso mi basta generare uno userID ed una psw arbitrari, so che avrò una risposta con i campi definiti. Prendo la nonce dal request packet, fare nonce con la psw che ho scelto (Chosen Plaintext atck), quindi ho un keystream e posso fare bruteforce con dictionary atk.\\ Attacco alla password dell'utente: parto dl nome della vittima che voglio, metto psw arbitraria, ottengo unser password attribute e la psw encryptata che è scelta da me, pulisco encrypted password ed ho un keystream valido. Suppongo di voler fare brute force di un utente: faccio trial di psw, ma è lento e verrei bloccato dopo un certo n° attempts. Ma così ho trovato il modo di bypassare il server: mi metto dietro il NAS e spoofo tutta una serie di request (non è detto che il server faccia check che la nonce sia diversa) e faccio dictonary attack.
\subsubsection{Poor PRNG implementations}
PRNG è una delle parti più importanti in security.Security in RADIUS richiede un Request Authenticator unico e fresh: ho un req auth di 128bit, 16 byte.\\ esempio, prendo un random generator, lo chiamo rand(), genera 4 byte:
\begin{itemize}
\item Lo chiamo 4 volte.
\item Lo chiamo una volta e riempio di 0
\item Faccio md5() del risultato della chiamata.
\end{itemize}
Quale meccanismo uso? PRNG ha un periodo, rand() ha un periodo di $2^{32}$: periodo è la lunghezza del ciclo affinché non si ripeta lo stesso pattern (in molti casi, per non crypto PRNG il periodo è $2^{n°_bit}$). Mando il RADIUS packet e l'auth req. non dovrebbe ripetersi. Se faccio merge di più pacchetti: il periodo si accorcia, perché abbiamo preso più valori. In termini di entropia, 2 e 3 sono quasi equivalenti: sono sicuro se la nonce non si ripete, l'approccio 1 ha $2^{30}$ come periodo, mentre 2-3 avrebbero la stessa sicurezza.\\ La maggiora parte delle implementazioni di RADIUS usano non crypto PRNG. Se uso PRNG che è buono dal punto di vista statistico, ma può non essere dal punto di vista della sicurezza:
\begin{enumerate}
\item Predictability: non devo poter predirre quale sarà il prossimo valore 
\item Periodo: prima o poi il generatore si ripete, non voglio short cycles.
\item Random generator garantisce valori unici o ripetuti: ci sono alcuni random generator in cui è possibile garantire che se genero blocchi di dati, questi sono diversi. es: AES ha blocchi che non sono ripetuti
\end{enumerate}
Riguardo al ciclo:\\
Linear Congruential Generator: R$_{n+1}$ = (a $\cdot$ R$_{n}$+b), nel caso di rand a e b scelti in modo che il ciclo sia di $2^{32}$, nel caso di questi generatori se conosci un valore li conosci tutti.\\ Mersenne Twister: $2^{19937}$-1 è ciclo "infinito", ma i valori si ripetono.\\ Se so che i valori si ripetono, al sicurezza è $2^{\frac{N}{2}}$, altrimenti è $2^N$.\\ Ora che so che RADIUS ura poor PRNG, mi aspetto che auth request ripete: stesso problema di WEP, posso avere più o meno predicibilità e penso ai possibili attacchi. Sono tutti reply attack: monitoro un certo n° attempts in cui ho utenti validi, ogni richiesta avrà una risposta con delle nonce. Creo tabella:
Auth request nonce|Access accept packet. Access accept packet mi da il permesso di accedere al sistema. Creo dizionario, dopo un po' entro nella rete, NAS gemera una nuova access request che può contenere un numero che già è apparso, faccio reply di una risposta positiva e rispondo $\Rightarrow$ ho accesso alla rete.\\ Stesso alla user psw: è encryptata con MD5(segreto, auth), se auth si ripete il keystream è lo stesso $\Rightarrow$ two time pad e posso romperlo. Creo dizionario di request auth|user psw $\oplus$ MD5(secret, nonce).Raccolgo il cipher text, quando avrò la ripetizione (di uno stesso keystream con una psw diversa), faccio XOR e ottengo lo XOR fra due password e sfruttando la low entropy le ottengo entrambe.\\ Posso anche spoofare le password, incrementando il dizionario: aiuto un attacco passivo, uso psw finte che conosco $\Rightarrow$ ottengo la mia psw in XOR con il keystream, faccio lo XOR con la psw ed ottengo MD5 e quindi il keystream.\\ Ora se un utente arriva ed il keystream si ripete ottengo la password a gratis.
\subsection{Lezione da RADIUS}
Whitebox pentesting: alcuni siti usano nell'URL  uno SHA256(emailuser, rand()), se provo a loggarmi, faccio brute force per capire qual'è il valore rand() usato: devo creare $2^{32}$ hash (se rand ha questa periodicità), con 66M hash/sec, 1 min e ho enumerato tutto i possibili valori, ora so che se entra un altro utente dopo di me, posso usare il mio dizionario per prendere il valore successivo.\\ Cosa ho imparato da RADIUS:
\begin{itemize}
\item Do-it-all-in-one non ripaga: un protocollo applicativo non dovrebbe includere sicurezza.\\ Come rendo scuro un sistema? Sviluppo un protocollo apposito, come ad esempio TLS, e lo uso per rendere sicuro un protocollo non sicuro.
\item AAA protocol non dovrebbe implementare un meccanismo proprio, inoltre non includere algoritmi nell'algoritmo.
\end{itemize}
Attualmente: DIAMETER per migliorare RADIUS.
\subsection{AAA evolution: beyond RADIUS}
Quando parto da una soluzione, meglio cambiare poco.\\ RADIUS deployato anni fa, oggi RADIUS è standard de facto per AAA, spesso anche usato in Wi-FI, supporto universale per i device vendors.\\ Buon protocollo, ma con limitazioni funzionali:
\begin{itemize}
\item scalability: quando fu deployato c'era pochi utenti, ma ora sono molti. UDP è unreliable, potrei avere problemi di loss
\item diversità nelle tecnologie di accesso: prima dial up, ora Wi-Fi, 3G,4G etc..., devo supportare tutte: type|len|value era non sufficiente, 1 byte di type troppo poco.\\ Lista di possibili estensioni: più di 256 combinazioni, servono più byte di type.
\item interoperabilità: issue importante, ho un server central, ma non è realmente centralizzato (solo logicamente centralizzato), ho delle repliche ed è distribuito.\\ Tutti i server considerati proprietari, quindi difficile avere interoperabilità.
\end{itemize}
Nota di scalabilità: mando RADIUS request e RADIUS accept una volta per connessione, quindi traffico è irrilevante per la scalabilità. esempio: ho NAS a 48 porte, ogni 20 minuti ho in media una nuova combinazione: $\frac{1}{20}$ $minuti^{-1}$ ma $\cdot$ 48 = 2 call/minuto. Ma se numero di NAS aumenta, tipo a 10000: 400 request/secondo. Dopo access request ho anche accounting request e delivery $\Rightarrow$ traffic può arrivare a diversi Mbps, quindi se scalo può diventare difficile da gestire, potrei avere problemi di packet loss.\\ Quando dimensiono un sistema, di solito uso average load, ma non si considerano casi speciali: esempio, ho un crash e il device si reboota. Tutti i device rebootati mandano peek traffic: posso avere molta perdita, RADIUS non scala bene per colpa di UDP, ora serve reliability e quindi TCP o meglio.
\subsection{IETF evolution}
\begin{itemize}
\item Diameter: iniziato nel 1998, ora completato. Attività mosse in DiME(Diameter, Mainteinence, and Extensions WG).\\ AP a casa: PPPoE/PPPoA: protocolli per patchare la possibilità di far girare PPP su ethernet o ATM, doveva durare poco, ma attualmente alcuni lo usano ancora.
\item RADext: path a RADIUS, usato fino a che Diameter fosse diventato mainstream.
\end{itemize}
RADIUS: molto lavoro già fatto, pesanemente integrato, standard de facto. Diameter: protocollo nuovo, più potente e scelta perfetta per nuovi scenari.\\ Li tengo entrambi: lavoro duplicato ma è conveniente a livello di business, se qualcosa va male in Diameter ho backup che è RADIUS.
\subsubsection{DIAMETER}
Simile ad """un object-oriented "protocol design" """ (non dirlo alle persone), ho classe base da cui derivo classe derivata. Primo protocollo inventato come OO: DIAMETER non è un AA protocol, ma un protocollo di messaging/signaling generico a lvl applicativo.Definisco il DIAMETER base protocol: ho le primitive per supportare messaging/signaling transport.\\ Definisco il protocollo per trasportare i messaggi, lo faccio in un altra classe base che è AAA Transport profile(SCTP, TCP-based), deve essere reliable.\\ Ora derivo le specializzazioni: creo una applicazione DIAMETER differente per ogni uso necessario:
\begin{itemize}
\item DIAMETER mobile IPv4 app: per muovere IP
\item DIAMETER NAS app: questo è per il purpose di RADIUS.
\item DIAMETER credit control app
\item DIAMETER EAP app
\item DIAMETER SIP app
\end{itemize}
Nella base: tecniche per keep alive server, load balance etc.., eredito le proprietà e specializzo per lo specifico porpuse dell'applicazione.
\subsubsection{DIAMETER improvements}
SCTP: perché TCP può non essere buono.\\ esempio: ho un NAS che deve parlare col server AAA. Quando arriva connessione, devo settare comunicazione, NAS manda request al server. La voglio reliable: soluzione base è setuppare TPC connection per ogni connessione: devo fare il 3-way handshake, mando il pacchetto e poi aspetto ack e mando il FIN. Tutto st'accrocco per un singolo pacchetto.\\ Non faccio TCP conn per ogni connessione. Uso una singola connesisone TCP per gestire tutti pacchetti: implemento multithreaded server: ho due thread, uno di questi si blocca. Vorrei poter gestire il secondo pacchetto, ma TCP fa consegna ordinata, quindi non posso creare gap nel protocollo: TCP mi da tutto in ordine, è uno dei goal. Ho un flow multiplo embeddato in una singola connessione TCP e quindi in un singolo flow.\\ Vorrei una connessione reliable che porta stream differenti, e vorrei un protocollo che garantisce che tutti i pacchetti nello stream siano letti nel giusto ordine, ma non di avere ordine fra gli stream: se il primo stream si blocca, vorrei bypassarlo e leggere il secondo. Effetto Head of the line blocking: anche se ho uno switch ad alta capacità, l'effetto impatta sulle performance.\\ Secondo problema di TCP: ho un NAS, per reliability ho una interfaccia ethernet, ma posso averne una di backup, ad esempio di backup (in altra tecnologia) così da garantire continuità. Ma l'IP address delle due connessioni è diverso e TCP socket usa la 4-pla: quindi se link fallisce devo inizializzare una nuova connessione (MPTCP lo risolve), vorrei supportare multi-homing: manage più IP address.\\ SCTP (Stream Control Transport Protocol) da queste due garanzie, protocollo migliore per canale di signaling dove trasmetto più flussi di dati. \\ storiella: perché se funziona così bene uso ancora TCP: chicken/egg problem. Standardizzazione bloccata dopo gli anni 2000, ad esempio anche IPv6. Problema dell'Internet Ossification: 1980/1990, con design spirit di Inernet che era End-to-end principle: nella rete telefonica originale, intelligenza nei device centrali, edge stupidi, in Internet la maggior parte dell'intelligenza ai bordi.\\1995-1998-2000: web, avvento di device più intelligente, NAT primo device necessario per far fronte al lack di device alla rete,  ma poi firewall, media converter ed altra roba messa sopra. Tutta una serie di middle boxes. Anche device come TCP accelerators, performance enanchements, etc... "intelligent devices". Arriva un nuovo protocollo: SCTP, comincio a connettere siti distanti, ma siccome traffico gira su questi device che lo reputano non noto, viene bloccato.\\ Servono middle boxes per supportarlo, ma i produttori lo fanno solo se l'evidenza mostra che è usato, ma come cazzo ti mostro che è usato se mi blocchi il traffico. Ora software networking: middleboxes diventano software e sono controllabili, 5G è rete softwarizzata.\\
\begin{itemize}
\item Reliable transport: uso SCTP, senno TCP se non posso
\item Standardizzazione in caso di errore: se server fallisce, come migrare verso altro server. DIAMETER: standard per scoprire queste situazioni:
\begin{itemize}
\item duplicate detection
\item controllo di ritrasmissioni a livello applicativo
\item fallimento di peer. DIAMETER è protcol p2p, server può startare comunicazione esplicitamente con NAS.
\end{itemize}
\item pacchetti PING-like per testare se il device è attivo o no.
\item Estensione dei limiti funzionali: header di RADIUS era corto, quello di DIAMETER è più complesso:  
\begin{itemize}
\item length di 3 byte
\item 3 byte comando ma anche ID per la specifica applicazione.\\ Id del pacchetto serve per matchare request-response, lo scenario nel mondo reale non è solo point-to-point: ho multi-hop, ogni pacchetto averà un ID specifico. Non so se voglio matchare comunicazione globale o locale, quindi DIAMETER introduce due identificatori:
\begin{itemize}
\item Hop-by-hop ID
\item End-to-end ID
\end{itemize}
\item altri flag: NAS può rispondere o far partire la comunicazione, sono in p2p: devo identificare se pacchetto è request o response, uso flag R, flag P sta per proxable e permette di specificare se il pacchetto può essere modificato da un proxy, flag E: messaggio di errore, flag T: messaggio potenzialmente ritrasmesso. esempio: \\ mando un pacchetto, non ricevo answare e retx. Ricevo risposta: se server era bloccato temporaneamente, potrebbe rispondere di nuovo: uso T flag, così da darti avvertimento.
\item AVPs: i vecchi T|L|V triplets, ora chiamati attribute,value,pairs. Codice , lunghezza e attributo ma anche altro: metto vendor ID che dice che il linguaggio non è di DIAMETER, ma è customizzato.4 byte di AVP code, perché uno era troppo poco.\\ Flags:
\begin{itemize}
\item V: vendor specific
\item M: sono NAS e supporto DIAMETER v4.2.1, server DIAMETER v3.9.8, NAS vuole usare un attributo della nuova versione, che server non ha. Ricevo packet, con attributo che non comprendo: se l'attributo è importante, non posso skipparlo. Conviene droppare packet e dire al NAS di non aver capito. M serve per dire di rimandare indietro, perché le info non comprese sono mandatory.
Risolvo interoperabilità.
\item P: se c'è encryption o no 
\end{itemize}
\item ho il campo dati
\end{itemize}
\end{itemize}
Mangement di intermediate entities: posso usare RADIUS agent per mandare relayed message,ma non c'era supporto al romaning.\\ Non devo solo fare roaming data, ma anche routing: se mi collego ad un peer distante, quello deve fare route al server del mio paese. 3 cose strandardizzate:
\begin{itemize}
\item Nessuno agent intermedio
\item Relay agent: sono a Roma, ma vengo dall'univeristà di Parigi, RADIUS server di Roma riceve la request, relay agent guarda al realm, ovvero il dominio di registrazione e nella sua routing table sa di dover mandare la richiesta al server RADIUS di Parigi.
\item Proxy agent: simile al relay, ma assumo che può modificare il messaggio: se ho un messaggio con TAG integrità, se uso proxy e modifica $\Rightarrow$ ho rotto tutto, è un MITM attack (proxy non ha la chiave per modificare il messaggio).
\end{itemize}
Eduroam: sistema che permette di roammare lungo le università confederate con eduroam e non richiede di avere credenziali specifiche. Cosa fa un utente che sta a Tor Vergata e vuole accedere, ma è di Malta: server parsa l'address e mi manda a Malta.\\ M se le confederazioni sono molte: che succede se il server di Malta è va giù e viene sostituito con nuovo server che ha cambiato ip? Deve comunicarlo a tutti gli altri, anche se aggiungo un server. C'è management nightmare: se uso relay agents o proxy agents c'è problema: le routing table sono embeddate, soluzione: centralized controller che tiene le routing tables. Tizio di Malta entra da Tor Vergata, va a server di Tor Vergata e server prima di inoltrare richiesta, chiede l'ip di Malta al centralized server: il dato rimane nel RADIUS server di Roma, ma il controllo è demandato al controller,posso usare trick di caching. Separazione fra controllo e dati $\Rightarrow$ redirect agent: gestisce solo le routing table, ora le routing table non sono embeddate nell relay agent, quindi ho le due operazioni separate.\\ Questo rende ad esempio possibile number portability
\end{document}